{"version":3,"sources":["util.ts","AppContext.tsx","ChannelsList.tsx","ChannelInfo.tsx","PlayerControls.tsx","Player.tsx","Radio.tsx","Header.tsx","ErrorBoundary.tsx","index.tsx"],"names":["fetchChannels","a","console","log","process","fetch","headers","json","response","areEqual","id1","id2","toString","AppContext","createContext","channels","favouriteChannels","undefined","currentChannel","isPlaying","updateCurrentChannel","channelId","togglePlayBack","nextChannel","prevChannel","toggleFavouriteChannel","info","AppContextProvider","children","search","window","location","URLSearchParams","get","useState","setCurrentChannel","setIsPlaying","setChannels","setFavouriteChannels","STORAGE_KEY_FAVOURITE_CHANNELS","STORAGE_KEY_CURRENT_CHANNEL","useEffect","init","sessionStorage","getItem","JSON","parse","useCallback","autoPlay","newChannel","find","channel","id","getCurrentChannelIndex","findIndex","length","prevSelectedChannel","error","setItem","stringify","currentChannelIndex","Provider","value","currentFavouriteChannels","filter","useAppContext","useContext","OuterWrapper","styled","div","Header","InnerWrapper","ItemWrapper","attrs","props","style","backgroundImage","image","ChannelDetails","imageSrc","onClick","ChannelsList","map","item","Container","expanded","ChannelInfo","isExpanded","isLoading","hasError","setExpanded","isFavourite","setIsFavourite","favouriteChannel","onHandleShare","navigator","share","params","set","title","text","url","href","replace","Image","src","width","maxHeight","maxWidth","Box","direction","justify","pad","margin","Button","size","icon","Favorite","primary","Share","Text","textAlign","Spinner","Wrapper","PlayerControls","Previous","PauseFill","PlayFill","plain","Next","Player","setIsLoading","setHasError","setIsExpanded","playerRef","useRef","audioSrc","hls","Hls","enableWorker","current","attachMedia","on","Events","MEDIA_ATTACHED","loadSource","MANIFEST_PARSED","play","catch","ERROR","event","data","fatal","type","ErrorTypes","NETWORK_ERROR","stopLoad","MEDIA_ERROR","recoverMediaError","isSupported","document","destroy","setTimeout","paused","pause","ref","Down","App","setAutoPlay","formatSuggestions","suggestedChannels","suggestedChannel","toLowerCase","indexOf","index","list","label","align","gap","border","borderRadius","selectedChannel","setSelectedChannel","suggestionOpen","setSuggestionOpen","suggestions","setSuggestions","selectedChannelTitle","setSelectedChannelTitle","onInputChange","newValue","target","trim","onSuggestionSelect","suggestion","onSuggestionsOpen","onSuggestionsClose","elevation","borderBottomLeftRadius","borderBottomRightRadius","TextInput","Search","reverse","placeholder","onChange","ErrorBoundary","state","this","Component","myCustomTheme","deepMerge","dark","global","drop","background","shadowSize","extend","medium","light","font","family","input","weight","render","Grommet","full","theme","Radio","getElementById"],"mappings":"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","file":"static/js/main.e90f4507.chunk.js","sourcesContent":["// import * as cheerio from 'cheerio';\n\nexport interface IChannelInfo {\n  id: string;\n  title: string;\n  imageSrc: string;\n  audioSrc: string;\n}\n\n// const getChannelsFromScriptTag = (htmlStr: cheerio.Root) => {\n//   const script = htmlStr('script').get()[7].children[0].data;\n//   return JSON.parse(\n//     script\n//       .match(/\\{(.*?);/)[0]\n//       // Replace \":\" with \"@colon@\" if it's between double-quotes\n//       .replace(/:\\s*\"([^\"]*)\"/g, (_: unknown, p1: string) => {\n//         return ': \"' + p1.replace(/:/g, '@colon@') + '\"';\n//       })\n\n//       // Replace \":\" with \"@colon@\" if it's between single-quotes\n//       .replace(/:\\s*'([^']*)'/g, (_: unknown, p1: string) => {\n//         return ': \"' + p1.replace(/:/g, '@colon@') + '\"';\n//       })\n\n//       // Add double-quotes around any tokens before the remaining \":\"\n//       .replace(/(['\"])?([a-z0-9A-Z_]+)(['\"])?\\s*:/g, '\"$2\": ')\n\n//       // Turn \"@colon@\" back into \":\"\n//       .replace(/@colon@/g, ':')\n//       .replace(/\\,(?!\\s*?[\\{\\[\\\"\\'\\w])/g, '')\n//       .replace(';', '')\n//   );\n// };\n\nconst fetchChannels = async (\n\n): Promise<IChannelInfo[]> => {\n  console.log(process.env);\n  const response = await (await fetch(\n    'https://player-b7f2.restdb.io/rest/air-channels'\n    , {\n      headers: {\n        'x-apikey': process.env.REACT_APP_RESTDB_API_KEY || '612c3e3f43cedb6d1f97ea9f'\n      }\n    })).json();\n  return response as IChannelInfo[];\n\n\n  // const response = await (await fetch(\n  //   'https://newsonair.com/playersource.php'\n  // )).text();\n  // const html = cheerio.load(response);\n  // const channels = getChannelsFromScriptTag(html);\n\n  // const list = Object.entries(channels).map(\n  //   (item: [string, { name: string; image: string; live_url: string }]) => {\n  //     const [key, value] = item;\n  //     return {\n  //       id: key,\n  //       title: value.name,\n  //       imageSrc: value.image,\n  //       audioSrc: value.live_url\n  //     };\n  //   }\n  // );\n  // return list;\n};\n\nconst areEqual = (id1: string | number | null, id2: string | number | null): boolean => {\n  if (!id1 || !id2) {\n    return false;\n  }\n  return id1.toString() === id2.toString();\n}\n\n\nexport { fetchChannels, areEqual };\n","import React, {\n  createContext,\n  useState,\n  useContext,\n  useEffect,\n  useCallback\n} from 'react';\nimport { areEqual, fetchChannels, IChannelInfo } from './util';\n\ntype AppContextParams = {\n  channels: IChannelInfo[];\n  favouriteChannels: IChannelInfo[] | undefined;\n  currentChannel: IChannelInfo | null;\n  isPlaying: boolean;\n  updateCurrentChannel: (channelId: string) => void;\n  togglePlayBack: () => void;\n  nextChannel: () => void;\n  prevChannel: () => void;\n  toggleFavouriteChannel: (info: IChannelInfo) => void;\n};\n\nexport const AppContext = createContext<AppContextParams>({\n  channels: [],\n  favouriteChannels: undefined,\n  currentChannel: null,\n  isPlaying: false,\n  updateCurrentChannel: (channelId: string) => { },\n  togglePlayBack: () => { },\n  nextChannel: () => { },\n  prevChannel: () => { },\n  toggleFavouriteChannel: (info: IChannelInfo) => { }\n});\n\nexport const AppContextProvider = ({\n  children\n}: {\n  children: JSX.Element[] | JSX.Element;\n}): JSX.Element => {\n  const search = window.location.search;\n  const params = new URLSearchParams(search);\n  const channelId = params.get('channelId');\n  const [currentChannel, setCurrentChannel] = useState<IChannelInfo | null>(null);\n  const [isPlaying, setIsPlaying] = useState<boolean>(false);\n  const [channels, setChannels] = useState<IChannelInfo[]>([]);\n  const [favouriteChannels, setFavouriteChannels] = useState<IChannelInfo[]>()\n\n  const STORAGE_KEY_FAVOURITE_CHANNELS = 'favouriteChannels';\n  const STORAGE_KEY_CURRENT_CHANNEL = 'currentChannel';\n\n  useEffect(() => {\n    void init();\n  }, []);\n\n  const init = async () => {\n    setChannels(await fetchChannels());\n    const favouriteChannels = sessionStorage.getItem(STORAGE_KEY_FAVOURITE_CHANNELS);\n\n    if (favouriteChannels) {\n      setFavouriteChannels(JSON.parse(favouriteChannels))\n    }\n  };\n\n  const updateCurrentChannel = useCallback((\n    channelId: string,\n    autoPlay: boolean = true\n  ) => {\n    const newChannel = channels.find(channel => areEqual(channel.id, channelId));\n    if (newChannel) {\n      setCurrentChannel(newChannel);\n    }\n\n    if (autoPlay && !isPlaying) {\n      setIsPlaying(true);\n    }\n  }, [channels, isPlaying]);\n\n  const getCurrentChannelIndex = useCallback(\n    () => channels.findIndex(channel => currentChannel && areEqual(channel.id, currentChannel.id)),\n    [channels, currentChannel]\n  );\n\n  useEffect(() => {\n    if (!channels || !channels.length) {\n      return;\n    }\n\n    if (channelId) {\n      updateCurrentChannel(channelId, false);\n      return;\n    }\n\n    const prevSelectedChannel = sessionStorage.getItem(STORAGE_KEY_CURRENT_CHANNEL);\n    if (prevSelectedChannel) {\n      try {\n        setCurrentChannel(JSON.parse(prevSelectedChannel));\n      } catch (error) {\n        console.log({ error });\n      }\n    }\n  }, [channels, channelId, updateCurrentChannel]);\n\n  useEffect(() => {\n    if (!currentChannel) {\n      return;\n    }\n    sessionStorage.setItem(STORAGE_KEY_CURRENT_CHANNEL, JSON.stringify(currentChannel));\n  }, [currentChannel]);\n\n  useEffect(() => {\n    if (favouriteChannels) {\n      sessionStorage.setItem(STORAGE_KEY_FAVOURITE_CHANNELS, JSON.stringify(favouriteChannels));\n    }\n  }, [favouriteChannels])\n\n\n  const nextChannel = useCallback(() => {\n    const currentChannelIndex = getCurrentChannelIndex();\n\n    if (currentChannelIndex < channels.length - 1) {\n      setCurrentChannel(channels[currentChannelIndex + 1]);\n      return;\n    }\n\n    setCurrentChannel(channels[0]);\n  }, [channels, getCurrentChannelIndex]);\n\n  const prevChannel = useCallback(() => {\n    const currentChannelIndex = getCurrentChannelIndex();\n\n    if (currentChannelIndex >= 1) {\n      setCurrentChannel(channels[currentChannelIndex - 1]);\n      return;\n    }\n\n    setCurrentChannel(channels[channels.length - 1]);\n  }, [channels, getCurrentChannelIndex]);\n\n\n  const togglePlayBack = () => {\n    setIsPlaying(isPlaying => !isPlaying);\n  };\n\n  const toggleFavouriteChannel = (info: IChannelInfo) => {\n    if (favouriteChannels) {\n      const favouriteChannel = favouriteChannels.find(channel => areEqual(channel.id, info.id));\n\n      if (favouriteChannel) { // remove from favourite and return \n        setFavouriteChannels(currentFavouriteChannels => currentFavouriteChannels?.filter(channel => !areEqual(channel.id, info.id)));\n        return;\n      }\n    }\n\n\n    setFavouriteChannels(currentFavouriteChannels => {\n      if (!currentFavouriteChannels) {\n        currentFavouriteChannels = []\n      };\n\n      return [...currentFavouriteChannels, info]\n    });\n  }\n\n  return (\n    <AppContext.Provider\n      value={{\n        channels,\n        favouriteChannels,\n        currentChannel,\n        isPlaying,\n        updateCurrentChannel,\n        togglePlayBack,\n        nextChannel,\n        prevChannel,\n        toggleFavouriteChannel\n      }}\n    >\n      {children}\n    </AppContext.Provider>\n  );\n};\n\nexport const useAppContext = (): AppContextParams => useContext(AppContext);\n","import React, { Fragment } from 'react';\nimport styled from 'styled-components';\nimport { useAppContext } from './AppContext';\nimport { IChannelInfo } from './util';\nconst OuterWrapper = styled.div``;\n\nconst Header = styled.div`\n  margin: 12px 20px;\n`;\n\nconst InnerWrapper = styled.div`\n  display: flex;\n  flex-flow: row wrap;\n  justify-content: center;\n  gap: 18px;\n  padding: 10px;\n  max-width: 800px;\n`;\nconst ItemWrapper = styled.div.attrs((props: { image: string }) => ({\n  style: {\n    backgroundImage: `url(${props.image})`\n  }\n})) <{ image: string }>`\n  border-radius: 8px;\n  overflow: hidden;\n  position: relative;\n  display: flex;\n  cursor: pointer;\n  background-repeat: no-repeat;\n  background-size: contain;\n  background-position: center;\n  width: 160px;\n  height: 160px;\n  border: 0.2px solid white;\n  background-color: white;\n  filter: drop-shadow(0 0 0.15rem white);\n\n  :hover {\n    opacity: 0.8;\n    cursor: pointer;\n  }\n`;\n\nconst ChannelDetails = (props: IChannelInfo) => {\n  const { updateCurrentChannel } = useAppContext();\n  return (\n    <ItemWrapper\n      image={props.imageSrc}\n      onClick={() => {\n        updateCurrentChannel(props.id);\n      }}\n    >\n      {/* <span>{props.title}</span> */}\n    </ItemWrapper>\n  );\n};\n\nconst ChannelsList = (): JSX.Element => {\n  const { channels, favouriteChannels } = useAppContext();\n\n  return (\n    <OuterWrapper>\n      {favouriteChannels && favouriteChannels.length &&\n        <Fragment>\n          <Header>Your favourite Stations</Header>\n          <InnerWrapper>\n            {favouriteChannels.map(item => (\n              <ChannelDetails key={item.id} {...item} />\n            ))}\n          </InnerWrapper>\n        </Fragment>}\n\n      <Header>On-Air Stations</Header>\n      <InnerWrapper>\n        {channels.map(item => (\n          <ChannelDetails key={item.id} {...item} />\n        ))}\n      </InnerWrapper>\n    </OuterWrapper>\n  );\n};\n\nexport default ChannelsList;\n","import styled from \"styled-components\";\nimport { Box, Button, Spinner } from 'grommet';\nimport { Image } from 'grommet/components/Image';\nimport { Text } from 'grommet/components/Text';\nimport React, { useEffect, useState } from 'react';\nimport { areEqual, IChannelInfo } from \"./util\";\nimport { Share, Favorite } from 'grommet-icons'\nimport { useAppContext } from \"./AppContext\";\n\n\n\nconst Container = styled.div<{ expanded: boolean }>`\n  display: flex;\n  align-items: center;\n  font-size: 16px;\n  flex: 1;\n  gap:  ${props => (props.expanded ? '50px' : '10px')};\n  padding: ${props => (props.expanded ? '50px' : undefined)};\n  width: ${props => (props.expanded ? '100%' : undefined)};\n  flex-direction: ${props => (props.expanded ? 'column' : 'row')};\n  cursor: pointer;\n`\n\ninterface IChannelInfoProps {\n    isLoading: boolean;\n    hasError: boolean;\n    isExpanded: boolean;\n    currentChannel: IChannelInfo;\n    onClick: (expanded: boolean) => void;\n}\n\nconst ChannelInfo = ({ isExpanded, isLoading, hasError, currentChannel, onClick }: IChannelInfoProps) => {\n    const [expanded, setExpanded] = useState<boolean>(false);\n    const [isFavourite, setIsFavourite] = useState<boolean>(false);\n\n    const { favouriteChannels, toggleFavouriteChannel } = useAppContext()\n\n    useEffect(() => {\n        setExpanded(isExpanded)\n    }, [isExpanded])\n\n    useEffect(() => {\n        if (!currentChannel?.id || !favouriteChannels) {\n            return;\n        }\n        const favouriteChannel = favouriteChannels.find(channel => areEqual(channel.id, currentChannel.id));\n        if (favouriteChannel && favouriteChannel.id) {\n            setIsFavourite(true)\n            return;\n        }\n        setIsFavourite(false);\n    }, [favouriteChannels, currentChannel])\n    const handleOnClick = () => {\n        setExpanded(true);\n        onClick(true);\n    }\n\n    const handleToggleFavourite = () => {\n        toggleFavouriteChannel(currentChannel);\n    }\n\n    const onHandleShare = async () => {\n        if (!currentChannel || !currentChannel.id) {\n            return;\n        }\n\n        if (navigator.share) {\n            const params = new URLSearchParams();\n            params.set('channelId', currentChannel.id);\n\n            try {\n                await navigator.share({\n                    title: currentChannel.title,\n                    text: 'Check out this online radio channel',\n                    url: `${window.location.href.replace(window.location.search, '')}?${params.toString()}`,\n                })\n            } catch (error) {\n                console.log(`Unable to share ${error}`)\n            }\n        }\n    }\n\n    return (\n        <Container\n            expanded={expanded}\n            onClick={handleOnClick}>\n\n            {currentChannel?.imageSrc &&\n                <Image src={currentChannel.imageSrc}\n                    width={expanded ? '70%' : 60}\n                    style={{ maxHeight: '30vh', maxWidth: '30vh' }} />}\n\n            {expanded && <Box direction='row'\n                justify='between'\n                width='100%'\n                pad='0 15px'\n                margin='-80px 0 0'>\n                <Button size={'large'} icon={<Favorite />} primary={isFavourite} onClick={handleToggleFavourite} />\n                <Button size={'large'} icon={<Share />} onClick={onHandleShare} />\n            </Box>}\n\n            <Text size={expanded ? 'xlarge' : 'small'}\n                textAlign={'start'}>{currentChannel?.title}\n            </Text>\n\n            {isLoading\n                && !hasError && <Spinner />}\n        </Container>\n    )\n}\n\nexport default ChannelInfo;","import { Button } from 'grommet';\nimport React, { Fragment } from 'react';\nimport styled from 'styled-components';\nimport { useAppContext } from './AppContext';\n\nimport { PlayFill, PauseFill, Next, Previous } from 'grommet-icons'\n\nconst Wrapper = styled.div`\n  display: flex;\n  align-items: center;\n`;\n\nconst PlayerControls = (): JSX.Element => {\n  const {\n    currentChannel,\n    isPlaying,\n    togglePlayBack,\n    nextChannel,\n    prevChannel\n  } = useAppContext();\n  if (!currentChannel) {\n    return <Fragment />;\n  }\n\n  return (\n    <Wrapper>\n      <Button\n        icon={<Previous />}\n        onClick={() => prevChannel()}\n      />\n\n      <Button\n        icon={isPlaying ? <PauseFill /> : <PlayFill />}\n        onClick={() => togglePlayBack()}\n        plain={false}\n        size={'large'}\n      />\n\n      <Button\n        icon={<Next />}\n        onClick={() => nextChannel()}\n      />\n    </Wrapper>\n  );\n};\n\nexport default PlayerControls;\n","import { Button } from 'grommet';\nimport { Down } from 'grommet-icons';\nimport Hls, { ErrorData, ErrorTypes } from 'hls.js';\nimport React, { Fragment, useCallback, useEffect, useRef, useState } from 'react';\nimport styled from 'styled-components';\nimport { useAppContext } from './AppContext';\nimport ChannelInfo from './ChannelInfo';\nimport PlayerControls from './PlayerControls';\nimport { areEqual } from './util';\n\nconst Wrapper = styled.div<{ expanded: boolean }>`\n  position: fixed;\n  left: 0;\n  bottom: 0;\n  width: 100%;\n  background-color: #404040;\n  color: white;\n  text-align: center;\n  display: flex;\n  align-items: center;\n  padding:  ${props => (props.expanded ? '80px 0' : '6px 10px')};\n  flex-direction: ${props => (props.expanded ? 'column' : 'row')};\n  justify-content: ${props => (props.expanded ? 'space-around' : 'space-between')};\n  box-sizing: border-box;\n  filter: drop-shadow(0 0 0.20rem black);\n  height: ${props => (props.expanded ? '100%' : undefined)};\n`;\n\nexport interface IPlayerProps {\n  autoPlay?: boolean\n}\n\nconst Player = (props: IPlayerProps): JSX.Element => {\n  const search = window.location.search;\n  const params = new URLSearchParams(search);\n  const channelId = params.get('channelId');\n  const [isLoading, setIsLoading] = useState<boolean>(false)\n  const [hasError, setHasError] = useState<boolean>(false)\n  const { currentChannel, isPlaying } = useAppContext();\n  const [isExpanded, setIsExpanded] = useState<boolean>(false);\n  const playerRef = useRef<HTMLMediaElement>(null);\n\n  const init = useCallback((audioSrc: string): Hls | undefined => {\n    const hls = new Hls({\n      enableWorker: true\n    });\n\n    if (playerRef.current != null) {\n      hls.attachMedia(playerRef.current);\n    }\n\n    hls.on(Hls.Events.MEDIA_ATTACHED, () => {\n      setHasError(false);\n      setIsLoading(true);\n\n      hls.loadSource(audioSrc);\n\n      hls.on(Hls.Events.MANIFEST_PARSED, () => {\n        setIsLoading(false);\n        if (props.autoPlay) {\n          playerRef?.current\n            ?.play()\n            .catch(() =>\n              console.log(\n                'Unable to autoplay prior to user interaction with the dom.'\n              )\n            );\n        }\n      });\n    });\n\n    hls.on(Hls.Events.ERROR, (event, data: ErrorData) => {\n      setHasError(true);\n\n      // if ((data.type === ErrorTypes.NETWORK_ERROR || data.type === ErrorTypes.MEDIA_ERROR) && isPlaying) {\n      //   // togglePlayBack()\n      // }\n\n      if (data.fatal) {\n        switch (data.type) {\n          case ErrorTypes.NETWORK_ERROR:\n            hls.stopLoad()\n            break;\n          case ErrorTypes.MEDIA_ERROR:\n            hls.recoverMediaError();\n            break;\n          default:\n            break;\n        }\n      }\n    });\n\n    return hls;\n  }, [props.autoPlay]);\n\n  const getAudioElement = () => {\n    // If Media Source is supported, use HLS.js to play video\n    if (Hls.isSupported()) {\n      return <audio ref={playerRef} />\n    }\n    // Fallback to using a regular video player if HLS is supported by default in the user's browser\n    return <audio ref={playerRef} src={currentChannel?.audioSrc} autoPlay={props.autoPlay} />;\n  }\n\n  useEffect(() => {\n    let hls: Hls | undefined;\n    // Check for Media Source support\n    if (Hls.isSupported() && currentChannel?.audioSrc) {\n      hls = init(currentChannel?.audioSrc);\n\n      document.title = `Radio - ${currentChannel.title}`\n    }\n\n    return () => {\n      if (hls != null) {\n        hls.destroy();\n      }\n    };\n  }, [init, currentChannel]);\n\n  useEffect(() => {\n    if (currentChannel && areEqual(currentChannel.id, channelId)) {\n      setIsExpanded(true);\n    }\n  }, [currentChannel, channelId])\n\n  useEffect(() => {\n    if (isPlaying) {\n      setTimeout(() => {\n        if (playerRef.current?.paused && !isLoading) {\n          playerRef?.current.play();\n        }\n      }, 0)\n\n      return;\n    }\n    playerRef.current?.pause()\n  }, [isPlaying, isLoading])\n\n  if (!currentChannel?.audioSrc) {\n    return <Fragment />\n  }\n\n  return (\n    <Wrapper expanded={isExpanded}>\n      {getAudioElement()}\n      {isExpanded && <Button\n        icon={<Down size={'large'} />}\n        onClick={() => setIsExpanded(false)}\n      />}\n      <ChannelInfo hasError={hasError}\n        isExpanded={isExpanded}\n        isLoading={isLoading}\n        currentChannel={currentChannel}\n        onClick={(expanded: boolean) => { setIsExpanded(expanded) }} />\n      <PlayerControls />\n    </Wrapper>);\n}\n\n\nexport default Player;\n","import { Spinner } from 'grommet';\nimport React, { useEffect, useState } from 'react';\nimport styled from 'styled-components';\nimport { useAppContext } from './AppContext';\nimport ChannelsList from './ChannelsList';\nimport Player from './Player';\n\nconst Container = styled.div`\n  min-height: 100%;\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  align-items: center;\n  margin-bottom: 80px;\n`;\n\nconst App = () => {\n  const { channels, isPlaying } = useAppContext();\n  const [autoPlay, setAutoPlay] = useState<boolean>(false);\n\n  useEffect(() => {\n    if (isPlaying && !autoPlay) {\n      setAutoPlay(true);\n    }\n  }, [autoPlay, isPlaying]);\n\n  return (\n    <Container>\n      {channels && channels.length ? <>\n        <ChannelsList />\n        <Player autoPlay={autoPlay} />\n      </> : <Spinner />}\n    </Container>\n  );\n};\n\nexport default App;\n","import { Box, Image, Text, TextInput } from 'grommet';\nimport { Search } from 'grommet-icons';\nimport React, { useCallback, useEffect, useState } from 'react';\nimport styled from 'styled-components';\nimport { useAppContext } from './AppContext';\nimport { IChannelInfo } from './util';\n\nconst OuterWrapper = styled.div`\n  position: sticky;\n  top: 0;\n  z-index: 3;\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  background-color: #fff;\n  background-color: var(--bg-primary-color);\n  filter: drop-shadow(0 0 0.20rem black);\n`;\nconst InnerWrapper = styled.div`\n  display: flex;\n  flex-direction: row;\n  justify-content: center;\n  justify-content: space-between;\n  padding: 0 20px;\n  height: 72px;\n  border-bottom: 1px solid #ccc;\n  background-color: black;\n  align-items: center;\n`;\n\ninterface ISuggestion {\n  label: JSX.Element, value: string, channel: IChannelInfo\n}\n\nconst formatSuggestions = (suggestedChannels: IChannelInfo[], value: string = ''): ISuggestion[] =>\n  suggestedChannels\n    .filter(\n      suggestedChannel =>\n        suggestedChannel.title.toLowerCase().indexOf(value.toLowerCase()) >= 0\n    )\n    .map((suggestedChannel, index, list) => ({\n      label: (\n        <Box\n          direction=\"row\"\n          align=\"center\"\n          gap=\"small\"\n          border={index < list.length - 1 ? 'bottom' : undefined}\n          pad=\"small\"\n        >\n          <Image\n            width=\"80px\"\n            src={suggestedChannel.imageSrc}\n            style={{ borderRadius: '8px' }}\n          />\n          <Text size={'small'}>\n            {suggestedChannel?.title}\n          </Text>\n        </Box>\n      ),\n      value: suggestedChannel.title,\n      channel: suggestedChannel\n    }));\n\nconst Header = (): JSX.Element => {\n  const { channels, updateCurrentChannel } = useAppContext();\n  const [selectedChannel, setSelectedChannel] = useState<IChannelInfo>();\n  const [suggestionOpen, setSuggestionOpen] = useState(false);\n  const [suggestions, setSuggestions] = useState<ISuggestion[]>([]);\n  const [selectedChannelTitle, setSelectedChannelTitle] = useState<string>('')\n\n  useEffect(() => {\n    if (selectedChannel && selectedChannel.id) {\n      updateCurrentChannel(selectedChannel.id)\n    }\n\n  }, [selectedChannel, updateCurrentChannel])\n\n  const onInputChange = useCallback(\n    event => {\n      const { value: newValue } = event.target;\n      setSelectedChannelTitle(newValue);\n      setSelectedChannel(newValue)\n\n      if (!newValue.trim()) {\n        setSuggestions([]);\n      } else {\n        setSuggestions(formatSuggestions(channels, newValue));\n      }\n    },\n    [channels]\n  );\n\n  const onSuggestionSelect = useCallback(\n    event => {\n      setSelectedChannel(event.suggestion.channel);\n      setSelectedChannelTitle(event.suggestion.value);\n    },\n    []\n  );\n\n  const onSuggestionsOpen = useCallback(() => {\n    setSuggestions(formatSuggestions(channels, selectedChannel?.title));\n    setSuggestionOpen(true);\n  }, [channels, selectedChannel]);\n\n  const onSuggestionsClose = useCallback(() => {\n    setSuggestions([]);\n    setSuggestionOpen(false);\n    setSelectedChannel(undefined);\n    setSelectedChannelTitle('')\n  }, []);\n\n  return (\n    <OuterWrapper>\n      <InnerWrapper>\n        <h1>Radio</h1>\n        <Box\n          width=\"medium\"\n          gap=\"medium\"\n          direction=\"row\"\n          align=\"center\"\n          elevation={suggestionOpen ? 'medium' : undefined}\n          style={\n            suggestionOpen\n              ? {\n                borderBottomLeftRadius: '0px',\n                borderBottomRightRadius: '0px',\n              }\n              : undefined\n          } pad={{ 'left': 'large' }}>\n          <TextInput\n            icon={<Search />}\n            reverse\n            placeholder=\"search\"\n            suggestions={suggestions}\n            value={selectedChannelTitle}\n            onChange={onInputChange}\n            onSuggestionsOpen={onSuggestionsOpen}\n            onSuggestionsClose={onSuggestionsClose}\n            onSuggestionSelect={onSuggestionSelect}\n          />\n        </Box>\n\n      </InnerWrapper>\n    </OuterWrapper>\n  );\n};\n\nexport default Header;\n","import React, { Component } from 'react';\n\ninterface IErrorState {\n  hasError: boolean;\n}\nclass ErrorBoundary extends Component<{}, IErrorState> {\n  state = { hasError: false };\n\n  static getDerivedStateFromError(error: unknown) {\n    if (error) {\n      console.log(error);\n      return { hasError: true };\n    }\n  }\n\n  componentDidCatch(error: unknown, info: unknown) {\n    console.log(error, info);\n  }\n\n  render() {\n    if (this.state.hasError) {\n      // You can render any custom fallback UI\n      return <h1>Something went wrong.</h1>;\n    }\n\n    return this.props.children;\n  }\n}\n\nexport default ErrorBoundary;\n","import React from 'react';\nimport { render } from 'react-dom';\nimport { Grommet } from 'grommet';\n\nimport { AppContextProvider } from './AppContext';\nimport Radio from './Radio';\nimport Header from './Header';\nimport { dark, ThemeType } from 'grommet/themes';\nimport { deepMerge } from 'grommet/utils';\n\nimport ErrorBoundary from './ErrorBoundary';\n\nconst myCustomTheme: ThemeType = deepMerge(dark, {\n  global: {\n    drop: {\n      background: '#444444',\n      shadowSize: 'medium',\n      extend: `\n          border-bottom-left-radius: 12px;\n          border-bottom-right-radius: 12px;\n          overflow: hidden;\n        `\n    },\n    elevation: {\n      dark: {\n        medium: '0 10px 20px rgba(0,0,0,0.19), 0 6px 6px rgba(0,0,0,0.23)'\n      },\n      light: {\n        medium: '0 10px 20px rgba(0,0,0,0.19), 0 6px 6px rgba(0,0,0,0.23)'\n      }\n    },\n    font: {\n      size: '14px',\n      family: 'Sora'\n    },\n    input: {\n      weight: 400\n    }\n  }\n});\n\nrender(\n  <ErrorBoundary>\n    <Grommet full theme={myCustomTheme}>\n      <AppContextProvider>\n        <Header />\n        <Radio />\n      </AppContextProvider>\n    </Grommet>\n  </ErrorBoundary>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}