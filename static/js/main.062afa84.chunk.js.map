{"version":3,"sources":["util.ts","AppContext.tsx","ChannelsList.tsx","PlayerControls.tsx","Player.tsx","Radio.tsx","Header.tsx","ErrorBoundary.tsx","index.tsx"],"names":["fetchChannels","a","fetch","headers","json","response","AppContext","createContext","channels","currentChannel","isPlaying","updateCurrentChannel","channelId","togglePlayBack","nextChannel","prevChannel","AppContextProvider","children","search","window","location","URLSearchParams","get","useState","setCurrentChannel","setIsPlaying","setChannels","useEffect","init","useCallback","autoPlay","newChannel","find","channel","id","getCurrentChannelIndex","findIndex","length","prevSelectedchannel","sessionStorage","getItem","JSON","parse","error","console","log","setItem","stringify","currentChannelIndex","Provider","value","useAppContext","useContext","OuterWrapper","styled","div","Header","InnerWrapper","ItemWrapper","attrs","props","style","backgroundImage","image","ChannelDetails","imageSrc","onClick","ChannelsList","map","item","Wrapper","PlayerControls","Button","icon","Previous","PauseFill","PlayFill","plain","size","Next","expanded","undefined","ChannelInfo","Player","isLoading","setIsLoading","hasError","setHasError","isExpanded","setIsExpanded","playerRef","useRef","audioSrc","hls","Hls","enableWorker","current","attachMedia","on","Events","MEDIA_ATTACHED","loadSource","MANIFEST_PARSED","play","catch","ERROR","event","data","fatal","type","ErrorTypes","NETWORK_ERROR","stopLoad","MEDIA_ERROR","recoverMediaError","isSupported","document","title","destroy","setTimeout","paused","pause","ref","src","Down","Image","width","maxHeight","maxWidth","Text","textAlign","Spinner","Container","App","setAutoPlay","formatSuggestions","suggestedChannels","filter","suggestedChannel","toLowerCase","indexOf","index","list","label","Box","direction","align","gap","border","pad","borderRadius","selectedChannel","setSelectedChannel","suggestionOpen","setSuggestionOpen","suggestions","setSuggestions","selectedChannelTitle","setSelectedChannelTitle","onInputChange","newValue","target","trim","onSuggestionSelect","suggestion","onSuggestionsOpen","onSuggestionsClose","elevation","borderBottomLeftRadius","borderBottomRightRadius","TextInput","Search","reverse","placeholder","onChange","ErrorBoundary","state","info","this","Component","myCustomTheme","deepMerge","dark","global","drop","background","shadowSize","extend","medium","light","font","family","input","weight","render","Grommet","full","theme","Radio","getElementById"],"mappings":"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","file":"static/js/main.062afa84.chunk.js","sourcesContent":["// import * as cheerio from 'cheerio';\r\n\r\nexport interface IChannelInfo {\r\n  id: string;\r\n  title: string;\r\n  imageSrc: string;\r\n  audioSrc: string;\r\n}\r\n\r\n// const getChannelsFromScriptTag = (htmlStr: cheerio.Root) => {\r\n//   const script = htmlStr('script').get()[7].children[0].data;\r\n//   return JSON.parse(\r\n//     script\r\n//       .match(/\\{(.*?);/)[0]\r\n//       // Replace \":\" with \"@colon@\" if it's between double-quotes\r\n//       .replace(/:\\s*\"([^\"]*)\"/g, (_: unknown, p1: string) => {\r\n//         return ': \"' + p1.replace(/:/g, '@colon@') + '\"';\r\n//       })\r\n\r\n//       // Replace \":\" with \"@colon@\" if it's between single-quotes\r\n//       .replace(/:\\s*'([^']*)'/g, (_: unknown, p1: string) => {\r\n//         return ': \"' + p1.replace(/:/g, '@colon@') + '\"';\r\n//       })\r\n\r\n//       // Add double-quotes around any tokens before the remaining \":\"\r\n//       .replace(/(['\"])?([a-z0-9A-Z_]+)(['\"])?\\s*:/g, '\"$2\": ')\r\n\r\n//       // Turn \"@colon@\" back into \":\"\r\n//       .replace(/@colon@/g, ':')\r\n//       .replace(/\\,(?!\\s*?[\\{\\[\\\"\\'\\w])/g, '')\r\n//       .replace(';', '')\r\n//   );\r\n// };\r\n\r\nconst fetchChannels = async (\r\n\r\n): Promise<IChannelInfo[]> => {\r\n  const response = await (await fetch(\r\n    'https://player-b7f2.restdb.io/rest/air-channels'\r\n    , {\r\n      headers: {\r\n        'x-apikey': \"612c3e3f43cedb6d1f97ea9f\"\r\n      }\r\n    })).json();\r\n  return response as IChannelInfo[];\r\n\r\n\r\n  // const response = await (await fetch(\r\n  //   'https://newsonair.com/playersource.php'\r\n  // )).text();\r\n  // const html = cheerio.load(response);\r\n  // const channels = getChannelsFromScriptTag(html);\r\n\r\n  // const list = Object.entries(channels).map(\r\n  //   (item: [string, { name: string; image: string; live_url: string }]) => {\r\n  //     const [key, value] = item;\r\n  //     return {\r\n  //       id: key,\r\n  //       title: value.name,\r\n  //       imageSrc: value.image,\r\n  //       audioSrc: value.live_url\r\n  //     };\r\n  //   }\r\n  // );\r\n  // return list;\r\n};\r\n\r\nexport { fetchChannels };\r\n","import React, {\r\n  createContext,\r\n  useState,\r\n  useContext,\r\n  useEffect,\r\n  useCallback\r\n} from 'react';\r\nimport { fetchChannels, IChannelInfo } from './util';\r\n\r\ntype AppContextParams = {\r\n  channels: IChannelInfo[];\r\n  currentChannel: IChannelInfo | null;\r\n  isPlaying: boolean;\r\n  updateCurrentChannel: (channelId: string) => void;\r\n  togglePlayBack: () => void;\r\n  nextChannel: () => void;\r\n  prevChannel: () => void;\r\n};\r\n\r\nexport const AppContext = createContext<AppContextParams>({\r\n  channels: [],\r\n  currentChannel: null,\r\n  isPlaying: false,\r\n  updateCurrentChannel: (channelId: string) => { },\r\n  togglePlayBack: () => { },\r\n  nextChannel: () => { },\r\n  prevChannel: () => { }\r\n});\r\n\r\nexport const AppContextProvider = ({\r\n  children\r\n}: {\r\n  children: JSX.Element[] | JSX.Element;\r\n}): JSX.Element => {\r\n  const search = window.location.search;\r\n  const params = new URLSearchParams(search);\r\n  const channelId = params.get('channelId');\r\n  const [currentChannel, setCurrentChannel] = useState<IChannelInfo | null>(null);\r\n  const [isPlaying, setIsPlaying] = useState<boolean>(false);\r\n  const [channels, setChannels] = useState<IChannelInfo[]>([]);\r\n\r\n  useEffect(() => {\r\n    void init();\r\n  }, []);\r\n\r\n  const init = async () => {\r\n    setChannels(await fetchChannels());\r\n  };\r\n\r\n  const updateCurrentChannel = useCallback((\r\n    channelId: string,\r\n    autoPlay: boolean = true\r\n  ) => {\r\n    const newChannel = channels.find(channel => channel.id === channelId);\r\n    if (newChannel) {\r\n      setCurrentChannel(newChannel);\r\n    }\r\n\r\n    if (autoPlay && !isPlaying) {\r\n      setIsPlaying(true);\r\n    }\r\n  }, [channels, isPlaying]);\r\n\r\n  const getCurrentChannelIndex = useCallback(\r\n    () => channels.findIndex(channel => currentChannel && channel.id === currentChannel.id),\r\n    [channels, currentChannel]\r\n  );\r\n\r\n  useEffect(() => {\r\n    if (!channels || !channels.length) {\r\n      return;\r\n    }\r\n\r\n    if (channelId) {\r\n      updateCurrentChannel(channelId, false);\r\n      return;\r\n    }\r\n\r\n    const prevSelectedchannel = sessionStorage.getItem('currentChannel');\r\n    if (prevSelectedchannel) {\r\n      try {\r\n        setCurrentChannel(JSON.parse(prevSelectedchannel));\r\n      } catch (error) {\r\n        console.log({ error });\r\n      }\r\n    }\r\n  }, [channels, channelId, updateCurrentChannel]);\r\n\r\n  useEffect(() => {\r\n    if (!currentChannel) {\r\n      return;\r\n    }\r\n    sessionStorage.setItem('currentChannel', JSON.stringify(currentChannel));\r\n  }, [currentChannel]);\r\n\r\n\r\n  const nextChannel = useCallback(() => {\r\n    const currentChannelIndex = getCurrentChannelIndex();\r\n\r\n    if (currentChannelIndex < channels.length - 1) {\r\n      setCurrentChannel(channels[currentChannelIndex + 1]);\r\n      return;\r\n    }\r\n\r\n    setCurrentChannel(channels[0]);\r\n  }, [channels, getCurrentChannelIndex]);\r\n\r\n  const prevChannel = useCallback(() => {\r\n    const currentChannelIndex = getCurrentChannelIndex();\r\n\r\n    if (currentChannelIndex >= 1) {\r\n      setCurrentChannel(channels[currentChannelIndex - 1]);\r\n      return;\r\n    }\r\n\r\n    setCurrentChannel(channels[channels.length - 1]);\r\n  }, [channels, getCurrentChannelIndex]);\r\n\r\n  const togglePlayBack = () => {\r\n    setIsPlaying(isPlaying => !isPlaying);\r\n  };\r\n  return (\r\n    <AppContext.Provider\r\n      value={{\r\n        channels,\r\n        currentChannel,\r\n        isPlaying,\r\n        updateCurrentChannel,\r\n        togglePlayBack,\r\n        nextChannel,\r\n        prevChannel\r\n      }}\r\n    >\r\n      {children}\r\n    </AppContext.Provider>\r\n  );\r\n};\r\n\r\nexport const useAppContext = (): AppContextParams => useContext(AppContext);\r\n","import React from 'react';\r\nimport styled from 'styled-components';\r\nimport { useAppContext } from './AppContext';\r\nimport { IChannelInfo } from './util';\r\nconst OuterWrapper = styled.div``;\r\n\r\nconst Header = styled.div`\r\n  margin: 12px 20px;\r\n`;\r\n\r\nconst InnerWrapper = styled.div`\r\n  display: flex;\r\n  flex-flow: row wrap;\r\n  justify-content: center;\r\n  gap: 18px;\r\n  padding: 10px;\r\n  max-width: 800px;\r\n`;\r\nconst ItemWrapper = styled.div.attrs((props: { image: string }) => ({\r\n  style: {\r\n    backgroundImage: `url(${props.image})`\r\n  }\r\n})) <{ image: string }>`\r\n  border-radius: 8px;\r\n  overflow: hidden;\r\n  position: relative;\r\n  display: flex;\r\n  cursor: pointer;\r\n  background-repeat: no-repeat;\r\n  background-size: contain;\r\n  background-position: center;\r\n  width: 160px;\r\n  height: 160px;\r\n  border: 0.2px solid white;\r\n  background-color: white;\r\n  filter: drop-shadow(0 0 0.15rem white);\r\n\r\n  :hover {\r\n    opacity: 0.8;\r\n    cursor: pointer;\r\n  }\r\n`;\r\n\r\nconst ChannelDetails = (props: IChannelInfo) => {\r\n  const { updateCurrentChannel } = useAppContext();\r\n  return (\r\n    <ItemWrapper\r\n      image={props.imageSrc}\r\n      onClick={() => {\r\n        updateCurrentChannel(props.id);\r\n      }}\r\n    >\r\n      {/* <span>{props.title}</span> */}\r\n    </ItemWrapper>\r\n  );\r\n};\r\n\r\nconst ChannelsList = (): JSX.Element => {\r\n  const { channels } = useAppContext();\r\n\r\n  return (\r\n    <OuterWrapper>\r\n      <Header>On-Air Stations</Header>\r\n      <InnerWrapper>\r\n        {channels.map(item => (\r\n          <ChannelDetails key={item.id} {...item} />\r\n        ))}\r\n      </InnerWrapper>\r\n    </OuterWrapper>\r\n  );\r\n};\r\n\r\nexport default ChannelsList;\r\n","import { Button } from 'grommet';\nimport React, { Fragment } from 'react';\nimport styled from 'styled-components';\nimport { useAppContext } from './AppContext';\n\nimport { PlayFill, PauseFill, Next, Previous } from 'grommet-icons'\n\nconst Wrapper = styled.div`\n  display: flex;\n  align-items: center;\n`;\n\nconst PlayerControls = (): JSX.Element => {\n  const {\n    currentChannel,\n    isPlaying,\n    togglePlayBack,\n    nextChannel,\n    prevChannel\n  } = useAppContext();\n  if (!currentChannel) {\n    return <Fragment />;\n  }\n\n  return (\n    <Wrapper>\n      <Button\n        icon={<Previous />}\n        onClick={() => prevChannel()}\n      />\n\n      <Button\n        icon={isPlaying ? <PauseFill /> : <PlayFill />}\n        onClick={() => togglePlayBack()}\n        plain={false}\n        size={'large'}\n      />\n\n      <Button\n        icon={<Next />}\n        onClick={() => nextChannel()}\n      />\n    </Wrapper>\n  );\n};\n\nexport default PlayerControls;\n","import { Button, Spinner } from 'grommet';\r\nimport { Image } from 'grommet/components/Image';\r\nimport { Text } from 'grommet/components/Text';\r\nimport Hls, { ErrorData, ErrorTypes } from 'hls.js';\r\nimport React, { Fragment, useCallback, useEffect, useRef, useState } from 'react';\r\nimport styled from 'styled-components';\r\nimport { useAppContext } from './AppContext';\r\nimport PlayerControls from './PlayerControls';\r\nimport { Down } from 'grommet-icons'\r\n\r\nconst Wrapper = styled.div<{ expanded: boolean }>`\r\n  position: fixed;\r\n  left: 0;\r\n  bottom: 0;\r\n  width: 100%;\r\n  background-color: #404040;\r\n  color: white;\r\n  text-align: center;\r\n  display: flex;\r\n  align-items: center;\r\n  padding:  ${props => (props.expanded ? '80px 0' : '6px 10px')};\r\n  flex-direction: ${props => (props.expanded ? 'column' : 'row')};\r\n  justify-content: ${props => (props.expanded ? 'space-around' : 'space-between')};\r\n  box-sizing: border-box;\r\n  filter: drop-shadow(0 0 0.20rem black);\r\n  height: ${props => (props.expanded ? '100%' : undefined)};\r\n`;\r\n\r\nconst ChannelInfo = styled.div<{ expanded: boolean }>`\r\n  display: flex;\r\n  align-items: center;\r\n  font-size: 16px;\r\n  flex: 1;\r\n  gap:  ${props => (props.expanded ? '50px' : '10px')};\r\n  padding: ${props => (props.expanded ? '50px' : undefined)};\r\n  width: ${props => (props.expanded ? '100%' : undefined)};\r\n  flex-direction: ${props => (props.expanded ? 'column' : 'row')};\r\n`\r\n\r\nexport interface IPlayerProps {\r\n  autoPlay?: boolean\r\n}\r\n\r\nconst Player = (props: IPlayerProps): JSX.Element => {\r\n  const search = window.location.search;\r\n  const params = new URLSearchParams(search);\r\n  const channelId = params.get('channelId');\r\n  const [isLoading, setIsLoading] = useState<boolean>(false)\r\n  const [hasError, setHasError] = useState<boolean>(false)\r\n  const { currentChannel, isPlaying } = useAppContext();\r\n  const [isExpanded, setIsExpanded] = useState<boolean>(false);\r\n  const playerRef = useRef<HTMLMediaElement>(null);\r\n\r\n  const init = useCallback((audioSrc: string): Hls | undefined => {\r\n    const hls = new Hls({\r\n      enableWorker: true\r\n    });\r\n\r\n    if (playerRef.current != null) {\r\n      hls.attachMedia(playerRef.current);\r\n    }\r\n\r\n    hls.on(Hls.Events.MEDIA_ATTACHED, () => {\r\n      setHasError(false);\r\n      setIsLoading(true);\r\n\r\n      hls.loadSource(audioSrc);\r\n\r\n      hls.on(Hls.Events.MANIFEST_PARSED, () => {\r\n        setIsLoading(false);\r\n        if (props.autoPlay) {\r\n          playerRef?.current\r\n            ?.play()\r\n            .catch(() =>\r\n              console.log(\r\n                'Unable to autoplay prior to user interaction with the dom.'\r\n              )\r\n            );\r\n        }\r\n      });\r\n    });\r\n\r\n    hls.on(Hls.Events.ERROR, (event, data: ErrorData) => {\r\n      setHasError(true);\r\n\r\n      // if ((data.type === ErrorTypes.NETWORK_ERROR || data.type === ErrorTypes.MEDIA_ERROR) && isPlaying) {\r\n      //   // togglePlayBack()\r\n      // }\r\n\r\n      if (data.fatal) {\r\n        switch (data.type) {\r\n          case ErrorTypes.NETWORK_ERROR:\r\n            hls.stopLoad()\r\n            break;\r\n          case ErrorTypes.MEDIA_ERROR:\r\n            hls.recoverMediaError();\r\n            break;\r\n          default:\r\n            break;\r\n        }\r\n      }\r\n    });\r\n\r\n    return hls;\r\n  }, [props.autoPlay]);\r\n\r\n  const getAudioElement = () => {\r\n    // If Media Source is supported, use HLS.js to play video\r\n    if (Hls.isSupported()) {\r\n      return <audio ref={playerRef} />\r\n    }\r\n    // Fallback to using a regular video player if HLS is supported by default in the user's browser\r\n    return <audio ref={playerRef} src={currentChannel?.audioSrc} autoPlay={props.autoPlay} />;\r\n  }\r\n\r\n  useEffect(() => {\r\n    let hls: Hls | undefined;\r\n    // Check for Media Source support\r\n    if (Hls.isSupported() && currentChannel?.audioSrc) {\r\n      hls = init(currentChannel?.audioSrc);\r\n\r\n      document.title = `Radio - ${currentChannel.title}`\r\n    }\r\n\r\n    return () => {\r\n      if (hls != null) {\r\n        hls.destroy();\r\n      }\r\n    };\r\n  }, [init, currentChannel]);\r\n\r\n  useEffect(() => {\r\n    if (currentChannel && currentChannel.id === channelId) {\r\n      setIsExpanded(true);\r\n    }\r\n  }, [currentChannel, channelId])\r\n\r\n  useEffect(() => {\r\n    if (isPlaying) {\r\n      setTimeout(() => {\r\n        if (playerRef.current?.paused && !isLoading) {\r\n          playerRef?.current.play();\r\n        }\r\n      }, 0)\r\n\r\n      return;\r\n    }\r\n    playerRef.current?.pause()\r\n  }, [isPlaying, isLoading])\r\n\r\n  if (!currentChannel?.audioSrc) {\r\n    return <Fragment />\r\n  }\r\n\r\n  return (\r\n    <Wrapper expanded={isExpanded}>\r\n      {getAudioElement()}\r\n      {isExpanded && <Button\r\n        icon={<Down size={'large'} />}\r\n        onClick={() => setIsExpanded(false)}\r\n      />}\r\n      <ChannelInfo\r\n        expanded={isExpanded}\r\n        onClick={() => { setIsExpanded(true) }}>\r\n        {currentChannel?.imageSrc &&\r\n          <Image src={currentChannel.imageSrc}\r\n            width={isExpanded ? '70%' : 60}\r\n            style={{ maxHeight: '30vh', maxWidth: '30vh' }} />}\r\n        <Text size={isExpanded ? 'xlarge' : 'small'}\r\n          textAlign={'start'}>{currentChannel?.title}\r\n        </Text>\r\n        {isLoading\r\n          && !hasError && <Spinner />}\r\n      </ChannelInfo>\r\n      <PlayerControls />\r\n    </Wrapper>);\r\n}\r\n\r\n\r\nexport default Player;\r\n","import { Spinner } from 'grommet';\r\nimport React, { useEffect, useState } from 'react';\r\nimport styled from 'styled-components';\r\nimport { useAppContext } from './AppContext';\r\nimport ChannelsList from './ChannelsList';\r\nimport Player from './Player';\r\n\r\nconst Container = styled.div`\r\n  min-height: 100%;\r\n  display: flex;\r\n  flex-direction: column;\r\n  justify-content: center;\r\n  align-items: center;\r\n  margin-bottom: 80px;\r\n`;\r\n\r\nconst App = () => {\r\n  const { channels, isPlaying } = useAppContext();\r\n  const [autoPlay, setAutoPlay] = useState<boolean>(false);\r\n\r\n  useEffect(() => {\r\n    if (isPlaying && !autoPlay) {\r\n      setAutoPlay(true);\r\n    }\r\n  }, [autoPlay, isPlaying]);\r\n\r\n  return (\r\n    <Container>\r\n      {channels && channels.length ? <>\r\n        <ChannelsList />\r\n        <Player autoPlay={autoPlay} />\r\n      </> : <Spinner />}\r\n    </Container>\r\n  );\r\n};\r\n\r\nexport default App;\r\n","import { Box, Image, Text, TextInput } from 'grommet';\r\nimport { Search } from 'grommet-icons';\r\nimport React, { useCallback, useEffect, useState } from 'react';\r\nimport styled from 'styled-components';\r\nimport { useAppContext } from './AppContext';\r\nimport { IChannelInfo } from './util';\r\n\r\nconst OuterWrapper = styled.div`\r\n  position: sticky;\r\n  top: 0;\r\n  z-index: 3;\r\n  display: flex;\r\n  flex-direction: column;\r\n  justify-content: center;\r\n  background-color: #fff;\r\n  background-color: var(--bg-primary-color);\r\n  filter: drop-shadow(0 0 0.20rem black);\r\n`;\r\nconst InnerWrapper = styled.div`\r\n  display: flex;\r\n  flex-direction: row;\r\n  justify-content: center;\r\n  justify-content: space-between;\r\n  padding: 0 20px;\r\n  height: 72px;\r\n  border-bottom: 1px solid #ccc;\r\n  background-color: black;\r\n  align-items: center;\r\n`;\r\n\r\ninterface ISuggestion {\r\n  label: JSX.Element, value: string, channel: IChannelInfo\r\n}\r\n\r\nconst formatSuggestions = (suggestedChannels: IChannelInfo[], value: string = ''): ISuggestion[] =>\r\n  suggestedChannels\r\n    .filter(\r\n      suggestedChannel =>\r\n        suggestedChannel.title.toLowerCase().indexOf(value.toLowerCase()) >= 0\r\n    )\r\n    .map((suggestedChannel, index, list) => ({\r\n      label: (\r\n        <Box\r\n          direction=\"row\"\r\n          align=\"center\"\r\n          gap=\"small\"\r\n          border={index < list.length - 1 ? 'bottom' : undefined}\r\n          pad=\"small\"\r\n        >\r\n          <Image\r\n            width=\"80px\"\r\n            src={suggestedChannel.imageSrc}\r\n            style={{ borderRadius: '8px' }}\r\n          />\r\n          <Text size={'small'}>\r\n            {suggestedChannel?.title}\r\n          </Text>\r\n        </Box>\r\n      ),\r\n      value: suggestedChannel.title,\r\n      channel: suggestedChannel\r\n    }));\r\n\r\nconst Header = (): JSX.Element => {\r\n  const { channels, updateCurrentChannel } = useAppContext();\r\n  const [selectedChannel, setSelectedChannel] = useState<IChannelInfo>();\r\n  const [suggestionOpen, setSuggestionOpen] = useState(false);\r\n  const [suggestions, setSuggestions] = useState<ISuggestion[]>([]);\r\n  const [selectedChannelTitle, setSelectedChannelTitle] = useState<string>('')\r\n\r\n  useEffect(() => {\r\n    if (selectedChannel && selectedChannel.id) {\r\n      updateCurrentChannel(selectedChannel.id)\r\n    }\r\n\r\n  }, [selectedChannel, updateCurrentChannel])\r\n\r\n  const onInputChange = useCallback(\r\n    event => {\r\n      const { value: newValue } = event.target;\r\n      setSelectedChannelTitle(newValue);\r\n      setSelectedChannel(newValue)\r\n\r\n      if (!newValue.trim()) {\r\n        setSuggestions([]);\r\n      } else {\r\n        setSuggestions(formatSuggestions(channels, newValue));\r\n      }\r\n    },\r\n    [channels]\r\n  );\r\n\r\n  const onSuggestionSelect = useCallback(\r\n    event => {\r\n      setSelectedChannel(event.suggestion.channel);\r\n      setSelectedChannelTitle(event.suggestion.value);\r\n    },\r\n    []\r\n  );\r\n\r\n  const onSuggestionsOpen = useCallback(() => {\r\n    setSuggestions(formatSuggestions(channels, selectedChannel?.title));\r\n    setSuggestionOpen(true);\r\n  }, [channels, selectedChannel]);\r\n\r\n  const onSuggestionsClose = useCallback(() => {\r\n    setSuggestions([]);\r\n    setSuggestionOpen(false);\r\n    setSelectedChannel(undefined);\r\n    setSelectedChannelTitle('')\r\n  }, []);\r\n\r\n  return (\r\n    <OuterWrapper>\r\n      <InnerWrapper>\r\n        <h1>Radio</h1>\r\n        <Box\r\n          width=\"medium\"\r\n          gap=\"medium\"\r\n          direction=\"row\"\r\n          align=\"center\"\r\n          elevation={suggestionOpen ? 'medium' : undefined}\r\n          style={\r\n            suggestionOpen\r\n              ? {\r\n                borderBottomLeftRadius: '0px',\r\n                borderBottomRightRadius: '0px',\r\n              }\r\n              : undefined\r\n          } pad={{ 'left': 'large' }}>\r\n          <TextInput\r\n            icon={<Search />}\r\n            reverse\r\n            placeholder=\"search\"\r\n            suggestions={suggestions}\r\n            value={selectedChannelTitle}\r\n            onChange={onInputChange}\r\n            onSuggestionsOpen={onSuggestionsOpen}\r\n            onSuggestionsClose={onSuggestionsClose}\r\n            onSuggestionSelect={onSuggestionSelect}\r\n          />\r\n        </Box>\r\n\r\n      </InnerWrapper>\r\n    </OuterWrapper>\r\n  );\r\n};\r\n\r\nexport default Header;\r\n","import React, { Component } from 'react';\r\n\r\ninterface IErrorState {\r\n  hasError: boolean;\r\n}\r\nclass ErrorBoundary extends Component<{}, IErrorState> {\r\n  state = { hasError: false };\r\n\r\n  static getDerivedStateFromError(error: unknown) {\r\n    if (error) {\r\n      console.log(error);\r\n      return { hasError: true };\r\n    }\r\n  }\r\n\r\n  componentDidCatch(error: unknown, info: unknown) {\r\n    console.log(error, info);\r\n  }\r\n\r\n  render() {\r\n    if (this.state.hasError) {\r\n      // You can render any custom fallback UI\r\n      return <h1>Something went wrong.</h1>;\r\n    }\r\n\r\n    return this.props.children;\r\n  }\r\n}\r\n\r\nexport default ErrorBoundary;\r\n","import React from 'react';\nimport { render } from 'react-dom';\nimport { Grommet } from 'grommet';\n\nimport { AppContextProvider } from './AppContext';\nimport Radio from './Radio';\nimport Header from './Header';\nimport { dark, ThemeType } from 'grommet/themes';\nimport { deepMerge } from 'grommet/utils';\n\nimport ErrorBoundary from './ErrorBoundary';\n\nconst myCustomTheme: ThemeType = deepMerge(dark, {\n  global: {\n    drop: {\n      background: '#444444',\n      shadowSize: 'medium',\n      extend: `\n          border-bottom-left-radius: 12px;\n          border-bottom-right-radius: 12px;\n          overflow: hidden;\n        `\n    },\n    elevation: {\n      dark: {\n        medium: '0 10px 20px rgba(0,0,0,0.19), 0 6px 6px rgba(0,0,0,0.23)'\n      },\n      light: {\n        medium: '0 10px 20px rgba(0,0,0,0.19), 0 6px 6px rgba(0,0,0,0.23)'\n      }\n    },\n    font: {\n      size: '14px',\n      family: 'Sora'\n    },\n    input: {\n      weight: 400\n    }\n  }\n});\n\nrender(\n  <ErrorBoundary>\n    <Grommet full theme={myCustomTheme}>\n      <AppContextProvider>\n        <Header />\n        <Radio />\n      </AppContextProvider>\n    </Grommet>\n  </ErrorBoundary>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}