{"version":3,"sources":["util.ts","AppContext.tsx","Header.tsx","index.style.ts","ChannelsList.tsx","ChannelInfo.styles.tsx","ChannelInfo.tsx","PlayerControls.tsx","PlayerActions.tsx","Player.tsx","Radio.tsx","App.tsx","index.tsx"],"names":["fetchChannels","a","fetch","headers","process","json","response","areEqual","id1","id2","toString","resizeToMinimum","minimum","current","window","outerWidth","outerHeight","restricted","index","length","resizeTo","AppContext","createContext","channels","favouriteChannels","undefined","currentChannel","isPlaying","updateCurrentChannel","channelId","togglePlayBack","nextChannel","prevChannel","toggleFavouriteChannel","info","AppContextProvider","children","search","location","URLSearchParams","get","useState","setCurrentChannel","setIsPlaying","setChannels","setFavouriteChannels","STORAGE_KEY_FAVOURITE_CHANNELS","STORAGE_KEY_CURRENT_CHANNEL","useEffect","init","localStorage","getItem","JSON","parse","useCallback","autoPlay","newChannel","find","channel","id","getCurrentChannelIndex","findIndex","prevSelectedChannel","error","console","log","setItem","stringify","currentChannelIndex","Provider","value","currentFavouriteChannels","filter","useAppContext","useContext","OuterWrapper","styled","div","InnerWrapper","IconImage","img","formatSuggestions","suggestedChannels","suggestedChannel","title","toLowerCase","indexOf","map","list","label","Box","direction","align","gap","border","pad","Image","width","src","imageSrc","style","borderRadius","Text","size","Header","selectedChannel","setSelectedChannel","suggestionOpen","setSuggestionOpen","suggestions","setSuggestions","selectedChannelTitle","setSelectedChannelTitle","onInputChange","event","newValue","target","trim","onSuggestionSelect","suggestion","onSuggestionsOpen","onSuggestionsClose","alt","elevation","borderBottomLeftRadius","borderBottomRightRadius","left","TextInput","icon","Search","reverse","placeholder","onChange","theme","deepMerge","dark","global","drop","background","shadowSize","extend","medium","light","font","family","input","weight","ItemWrapper","attrs","props","backgroundImage","image","ChannelDetails","onClick","ChannelsList","item","Container","expanded","MediaArtContainer","MediaArt","IconButton","Button","ChannelInfo","isExpanded","isLoading","hasError","setExpanded","textAlign","Spinner","StatusWarning","PlayerControls","Previous","PauseFill","PlayFill","plain","Next","PlayerActions","isFavourite","setIsFavourite","favouriteChannel","onHandleShare","navigator","share","params","set","text","url","href","replace","Favorite","primary","Share","Player","setIsLoading","setHasError","setIsExpanded","playerRef","useRef","audioSrc","hls","Hls","enableWorker","attachMedia","on","Events","MEDIA_ATTACHED","loadSource","MANIFEST_PARSED","play","catch","ERROR","data","fatal","type","ErrorTypes","NETWORK_ERROR","stopLoad","MEDIA_ERROR","recoverMediaError","isSupported","document","destroy","setTimeout","paused","pause","ref","Down","Radio","setAutoPlay","App","addEventListener","removeEventListener","Grommet","full","render","getElementById"],"mappings":"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","file":"static/js/main.b85a583d.chunk.js","sourcesContent":["export interface IChannelInfo {\n    id: string\n    title: string\n    imageSrc: string\n    audioSrc: string\n}\n\nconst fetchChannels = async (): Promise<IChannelInfo[]> => {\n    const response = await (\n        await fetch('https://player-b7f2.restdb.io/rest/air-channels', {\n            headers: {\n                'x-apikey': process.env.REACT_APP_RESTDB_API_KEY || '',\n            },\n        })\n    ).json()\n    return response as IChannelInfo[]\n}\n\nconst areEqual = (\n    id1: string | number | null,\n    id2: string | number | null\n): boolean => {\n    if (!id1 || !id2) {\n        return false\n    }\n    return id1.toString() === id2.toString()\n}\n\nconst resizeToMinimum = (): void => {\n    const minimum: [number, number] = [500, 640]\n    const current: [number, number] = [window.outerWidth, window.outerHeight]\n    const restricted: [number, number] = current\n\n    for (let index = 0; index < restricted.length; index++) {\n        restricted[index] =\n            minimum[index] > current[index] ? minimum[index] : current[index]\n    }\n\n    window.resizeTo(restricted[0], restricted[1])\n}\n\nexport { fetchChannels, areEqual, resizeToMinimum }\n","/* eslint-disable @typescript-eslint/no-empty-function */\n/* eslint-disable @typescript-eslint/no-unused-vars */\nimport React, {\n    createContext,\n    useState,\n    useContext,\n    useEffect,\n    useCallback,\n} from 'react'\nimport { areEqual, fetchChannels, IChannelInfo } from './util'\n\ntype AppContextParams = {\n    channels: IChannelInfo[]\n    favouriteChannels: IChannelInfo[] | undefined\n    currentChannel: IChannelInfo | null\n    isPlaying: boolean\n    updateCurrentChannel: (channelId: string) => void\n    togglePlayBack: () => void\n    nextChannel: () => void\n    prevChannel: () => void\n    toggleFavouriteChannel: (info: IChannelInfo) => void\n}\n\nexport const AppContext = createContext<AppContextParams>({\n    channels: [],\n    favouriteChannels: undefined,\n    currentChannel: null,\n    isPlaying: false,\n    updateCurrentChannel: (channelId: string) => {},\n    togglePlayBack: () => {},\n    nextChannel: () => {},\n    prevChannel: () => {},\n    toggleFavouriteChannel: (info: IChannelInfo) => {},\n})\n\nexport const AppContextProvider = ({\n    children,\n}: {\n    children: JSX.Element[] | JSX.Element\n}): JSX.Element => {\n    const search = window.location.search\n    const params = new URLSearchParams(search)\n    const channelId = params.get('channelId')\n    const [currentChannel, setCurrentChannel] = useState<IChannelInfo | null>(\n        null\n    )\n    const [isPlaying, setIsPlaying] = useState<boolean>(false)\n    const [channels, setChannels] = useState<IChannelInfo[]>([])\n    const [favouriteChannels, setFavouriteChannels] = useState<IChannelInfo[]>()\n\n    const STORAGE_KEY_FAVOURITE_CHANNELS = 'favouriteChannels'\n    const STORAGE_KEY_CURRENT_CHANNEL = 'currentChannel'\n\n    useEffect(() => {\n        void init()\n    }, [])\n\n    const init = async () => {\n        setChannels(await fetchChannels())\n        const favouriteChannels = localStorage.getItem(\n            STORAGE_KEY_FAVOURITE_CHANNELS\n        )\n\n        if (favouriteChannels) {\n            setFavouriteChannels(JSON.parse(favouriteChannels))\n        }\n    }\n\n    const updateCurrentChannel = useCallback(\n        (channelId: string, autoPlay = true) => {\n            const newChannel = channels.find((channel) =>\n                areEqual(channel.id, channelId)\n            )\n            if (newChannel) {\n                setCurrentChannel(newChannel)\n            }\n\n            if (autoPlay && !isPlaying) {\n                setIsPlaying(true)\n            }\n        },\n        [channels, isPlaying]\n    )\n\n    const getCurrentChannelIndex = useCallback(\n        () =>\n            channels.findIndex(\n                (channel) =>\n                    currentChannel && areEqual(channel.id, currentChannel.id)\n            ),\n        [channels, currentChannel]\n    )\n\n    useEffect(() => {\n        if (!channels || !channels.length) {\n            return\n        }\n\n        if (channelId) {\n            updateCurrentChannel(channelId, false)\n            return\n        }\n\n        const prevSelectedChannel = localStorage.getItem(\n            STORAGE_KEY_CURRENT_CHANNEL\n        )\n        if (prevSelectedChannel) {\n            try {\n                setCurrentChannel(JSON.parse(prevSelectedChannel))\n            } catch (error) {\n                console.log({ error })\n            }\n        }\n    }, [channels, channelId, updateCurrentChannel])\n\n    useEffect(() => {\n        if (!currentChannel) {\n            return\n        }\n        localStorage.setItem(\n            STORAGE_KEY_CURRENT_CHANNEL,\n            JSON.stringify(currentChannel)\n        )\n    }, [currentChannel])\n\n    useEffect(() => {\n        if (favouriteChannels) {\n            localStorage.setItem(\n                STORAGE_KEY_FAVOURITE_CHANNELS,\n                JSON.stringify(favouriteChannels)\n            )\n        }\n    }, [favouriteChannels])\n\n    const nextChannel = useCallback(() => {\n        const currentChannelIndex = getCurrentChannelIndex()\n\n        if (currentChannelIndex < channels.length - 1) {\n            setCurrentChannel(channels[currentChannelIndex + 1])\n            return\n        }\n\n        setCurrentChannel(channels[0])\n    }, [channels, getCurrentChannelIndex])\n\n    const prevChannel = useCallback(() => {\n        const currentChannelIndex = getCurrentChannelIndex()\n\n        if (currentChannelIndex >= 1) {\n            setCurrentChannel(channels[currentChannelIndex - 1])\n            return\n        }\n\n        setCurrentChannel(channels[channels.length - 1])\n    }, [channels, getCurrentChannelIndex])\n\n    const togglePlayBack = () => {\n        setIsPlaying((isPlaying) => !isPlaying)\n    }\n\n    const toggleFavouriteChannel = (info: IChannelInfo) => {\n        if (favouriteChannels) {\n            const favouriteChannel = favouriteChannels.find((channel) =>\n                areEqual(channel.id, info.id)\n            )\n\n            if (favouriteChannel) {\n                // remove from favourite and return\n                setFavouriteChannels((currentFavouriteChannels) =>\n                    currentFavouriteChannels?.filter(\n                        (channel) => !areEqual(channel.id, info.id)\n                    )\n                )\n                return\n            }\n        }\n\n        setFavouriteChannels((currentFavouriteChannels) => {\n            if (!currentFavouriteChannels) {\n                currentFavouriteChannels = []\n            }\n\n            return [...currentFavouriteChannels, info]\n        })\n    }\n\n    return (\n        <AppContext.Provider\n            value={{\n                channels,\n                favouriteChannels,\n                currentChannel,\n                isPlaying,\n                updateCurrentChannel,\n                togglePlayBack,\n                nextChannel,\n                prevChannel,\n                toggleFavouriteChannel,\n            }}\n        >\n            {children}\n        </AppContext.Provider>\n    )\n}\n\nexport const useAppContext = (): AppContextParams => useContext(AppContext)\n","import { Box, Image, Text, TextInput } from 'grommet'\nimport { Search } from 'grommet-icons'\nimport React, { useCallback, useEffect, useState } from 'react'\nimport styled from 'styled-components'\nimport { useAppContext } from './AppContext'\nimport { IChannelInfo } from './util'\n\nconst OuterWrapper = styled.div`\n    position: sticky;\n    top: 0;\n    z-index: 3;\n    display: flex;\n    flex-direction: column;\n    justify-content: center;\n    background-color: #fff;\n    background-color: var(--bg-primary-color);\n    filter: drop-shadow(0 0 0.2rem black);\n`\nconst InnerWrapper = styled.div`\n    display: flex;\n    flex-direction: row;\n    justify-content: center;\n    justify-content: space-between;\n    padding: 0 20px;\n    height: 72px;\n    border-bottom: 1px solid grey;\n    background-color: rgba(64, 64, 64, 0.8);\n    align-items: center;\n`\n\nconst IconImage = styled.img`\n    border-radius: 50%;\n    width: 48px;\n    ::before {\n        content: '';\n        width: 48px;\n        height: 48px;\n        background-color: #ccc;\n        border-radius: 50%;\n        position: absolute;\n        top: 50%;\n        left: 24px;\n        transform: translateY(-50%);\n    }\n`\n\ninterface ISuggestion {\n    label: JSX.Element\n    value: string\n    channel: IChannelInfo\n}\n\nconst formatSuggestions = (\n    suggestedChannels: IChannelInfo[],\n    value = ''\n): ISuggestion[] =>\n    suggestedChannels\n        .filter(\n            (suggestedChannel) =>\n                suggestedChannel.title\n                    .toLowerCase()\n                    .indexOf(value.toLowerCase()) >= 0\n        )\n        .map((suggestedChannel, index, list) => ({\n            label: (\n                <Box\n                    direction=\"row\"\n                    align=\"center\"\n                    gap=\"small\"\n                    border={index < list.length - 1 ? 'bottom' : undefined}\n                    pad=\"small\"\n                >\n                    <Image\n                        width=\"80px\"\n                        src={suggestedChannel.imageSrc}\n                        style={{ borderRadius: '8px' }}\n                    />\n                    <Text size={'small'}>{suggestedChannel?.title}</Text>\n                </Box>\n            ),\n            value: suggestedChannel.title,\n            channel: suggestedChannel,\n        }))\n\nconst Header = (): JSX.Element => {\n    const { channels, updateCurrentChannel } = useAppContext()\n    const [selectedChannel, setSelectedChannel] = useState<IChannelInfo>()\n    const [suggestionOpen, setSuggestionOpen] = useState(false)\n    const [suggestions, setSuggestions] = useState<ISuggestion[]>([])\n    const [selectedChannelTitle, setSelectedChannelTitle] = useState<string>('')\n\n    useEffect(() => {\n        if (selectedChannel && selectedChannel.id) {\n            updateCurrentChannel(selectedChannel.id)\n        }\n    }, [selectedChannel, updateCurrentChannel])\n\n    const onInputChange = useCallback(\n        (event) => {\n            const { value: newValue } = event.target\n            setSelectedChannelTitle(newValue)\n            setSelectedChannel(newValue)\n\n            if (!newValue.trim()) {\n                setSuggestions([])\n            } else {\n                setSuggestions(formatSuggestions(channels, newValue))\n            }\n        },\n        [channels]\n    )\n\n    const onSuggestionSelect = useCallback((event) => {\n        setSelectedChannel(event.suggestion.channel)\n        setSelectedChannelTitle(event.suggestion.value)\n    }, [])\n\n    const onSuggestionsOpen = useCallback(() => {\n        setSuggestions(formatSuggestions(channels, selectedChannel?.title))\n        setSuggestionOpen(true)\n    }, [channels, selectedChannel])\n\n    const onSuggestionsClose = useCallback(() => {\n        setSuggestions([])\n        setSuggestionOpen(false)\n        setSelectedChannel(undefined)\n        setSelectedChannelTitle('')\n    }, [])\n\n    return (\n        <OuterWrapper>\n            <InnerWrapper>\n                <IconImage\n                    src={process.env.PUBLIC_URL + '/assets/icons/icon-x192.png'}\n                    alt=\"Logo\"\n                />\n                <Box\n                    width=\"medium\"\n                    gap=\"medium\"\n                    direction=\"row\"\n                    align=\"center\"\n                    elevation={suggestionOpen ? 'medium' : undefined}\n                    style={\n                        suggestionOpen\n                            ? {\n                                  borderBottomLeftRadius: '0px',\n                                  borderBottomRightRadius: '0px',\n                              }\n                            : undefined\n                    }\n                    pad={{ left: 'large' }}\n                >\n                    <TextInput\n                        icon={<Search />}\n                        reverse\n                        placeholder=\"search\"\n                        suggestions={suggestions}\n                        value={selectedChannelTitle}\n                        onChange={onInputChange}\n                        onSuggestionsOpen={onSuggestionsOpen}\n                        onSuggestionsClose={onSuggestionsClose}\n                        onSuggestionSelect={onSuggestionSelect}\n                    />\n                </Box>\n            </InnerWrapper>\n        </OuterWrapper>\n    )\n}\n\nexport default Header\n","import { dark, ThemeType } from 'grommet/themes'\nimport { deepMerge } from 'grommet/utils'\n\nconst theme: ThemeType = deepMerge(dark, {\n    global: {\n        drop: {\n            background: '#444444',\n            shadowSize: 'medium',\n            extend: `\n          border-bottom-left-radius: 12px;\n          border-bottom-right-radius: 12px;\n          overflow: hidden;\n        `,\n        },\n        elevation: {\n            dark: {\n                medium: '0 10px 20px rgba(0,0,0,0.19), 0 6px 6px rgba(0,0,0,0.23)',\n            },\n            light: {\n                medium: '0 10px 20px rgba(0,0,0,0.19), 0 6px 6px rgba(0,0,0,0.23)',\n            },\n        },\n        font: {\n            size: '14px',\n            family: 'Sora',\n        },\n        input: {\n            weight: 400,\n        },\n    },\n})\n\nexport default theme\n","import React, { Fragment } from 'react'\nimport styled from 'styled-components'\nimport { useAppContext } from './AppContext'\nimport { IChannelInfo } from './util'\nconst OuterWrapper = styled.div``\n\nconst Header = styled.div`\n    margin: 12px 20px;\n`\n\nconst InnerWrapper = styled.div`\n    display: flex;\n    flex-flow: row wrap;\n    justify-content: center;\n    gap: 18px;\n    padding: 10px;\n    max-width: 800px;\n`\nconst ItemWrapper = styled.div.attrs((props: { image: string }) => ({\n    style: {\n        backgroundImage: `url(${props.image})`,\n    },\n}))<{ image: string }>`\n    border-radius: 8px;\n    overflow: hidden;\n    position: relative;\n    display: flex;\n    cursor: pointer;\n    background-repeat: no-repeat;\n    background-size: contain;\n    background-position: center;\n    width: 160px;\n    height: 160px;\n    border: 0.2px solid white;\n    background-color: white;\n    filter: drop-shadow(0 0 0.15rem white);\n\n    :hover {\n        opacity: 0.8;\n        cursor: pointer;\n    }\n`\n\nconst ChannelDetails = (props: IChannelInfo) => {\n    const { updateCurrentChannel } = useAppContext()\n    return (\n        <ItemWrapper\n            image={props.imageSrc}\n            onClick={() => {\n                updateCurrentChannel(props.id)\n            }}\n        >\n            {/* <span>{props.title}</span> */}\n        </ItemWrapper>\n    )\n}\n\nconst ChannelsList = (): JSX.Element => {\n    const { channels, favouriteChannels } = useAppContext()\n\n    return (\n        <OuterWrapper>\n            {favouriteChannels && favouriteChannels.length && (\n                <Fragment>\n                    <Header>Your favourite Stations</Header>\n                    <InnerWrapper>\n                        {favouriteChannels.map((item) => (\n                            <ChannelDetails key={item.id} {...item} />\n                        ))}\n                    </InnerWrapper>\n                </Fragment>\n            )}\n\n            <Header>On-Air Stations</Header>\n            <InnerWrapper>\n                {channels.map((item) => (\n                    <ChannelDetails key={item.id} {...item} />\n                ))}\n            </InnerWrapper>\n        </OuterWrapper>\n    )\n}\n\nexport default ChannelsList\n","import styled from 'styled-components'\nimport { Box, Button, ButtonExtendedProps } from 'grommet'\n\nconst Container = styled.div<{ expanded: boolean }>`\n    display: flex;\n    justify-content: ${(props) => (props.expanded ? 'center' : 'left')};\n    align-items: center;\n    font-size: 16px;\n    gap: ${(props) => (props.expanded ? '50px' : '10px')};\n    padding: ${(props) => (props.expanded ? '10px' : undefined)};\n    width: ${(props) => (props.expanded ? '100%' : undefined)};\n    flex-direction: ${(props) => (props.expanded ? 'column' : 'row')};\n    cursor: pointer;\n`\n\nconst MediaArtContainer = styled(Box)<{ expanded: boolean }>`\n    flex-direction: row;\n    justify-content: center;\n    align-items: center;\n    gap: 20px;\n    width ${(props) => (props.expanded ? '100%' : undefined)};\n    padding: 0 15px\n`\n\nconst MediaArt = styled.img<{ expanded: boolean }>`\n    width: ${(props) => (props.expanded ? '50vh' : '60px')};\n    max-height: 50vh;\n    max-width: ${(props) => (props.expanded ? '50vh' : '60px')};\n    transition: max-width 0.15s ease-in-out;\n    border-radius: 6px;\n`\n\nconst IconButton = styled(Button)<ButtonExtendedProps>`\n    padding: ${(props) => (props.size === 'large' ? '18px' : '12px')};\n`\n\nexport { Container, MediaArtContainer, MediaArt, IconButton }\n","import { Spinner } from 'grommet'\nimport { StatusWarning } from 'grommet-icons'\nimport { Text } from 'grommet/components/Text'\nimport React, { useEffect, useState } from 'react'\nimport { Container, MediaArt, MediaArtContainer } from './ChannelInfo.styles'\nimport { IChannelInfo } from './util'\n\ninterface IChannelInfoProps {\n    isLoading: boolean\n    hasError: boolean\n    isExpanded: boolean\n    currentChannel: IChannelInfo\n    onClick: (expanded: boolean) => void\n}\n\nconst ChannelInfo = ({\n    isExpanded,\n    isLoading,\n    hasError,\n    currentChannel,\n    onClick,\n}: IChannelInfoProps): JSX.Element => {\n    const [expanded, setExpanded] = useState<boolean>(false)\n\n    useEffect(() => {\n        setExpanded(isExpanded)\n    }, [isExpanded])\n\n    const handleOnClick = () => {\n        setExpanded(true)\n        onClick(true)\n    }\n\n    return (\n        <Container expanded={expanded} onClick={handleOnClick}>\n            <MediaArtContainer expanded={expanded}>\n                {currentChannel?.imageSrc && (\n                    <MediaArt\n                        expanded={expanded}\n                        src={currentChannel.imageSrc}\n                        alt=\"Media art\"\n                    />\n                )}\n            </MediaArtContainer>\n\n            <Text size={expanded ? 'xlarge' : 'small'} textAlign={'start'}>\n                {currentChannel?.title}\n            </Text>\n\n            {isLoading && !hasError && <Spinner />}\n            {hasError && <StatusWarning />}\n        </Container>\n    )\n}\n\nexport default ChannelInfo\n","import { Button } from 'grommet'\nimport React, { Fragment } from 'react'\nimport styled from 'styled-components'\nimport { useAppContext } from './AppContext'\n\nimport { PlayFill, PauseFill, Next, Previous } from 'grommet-icons'\nimport { IconButton } from './ChannelInfo.styles'\n\nconst Container = styled.div<{ expanded: boolean }>`\n    display: flex;\n    align-items: center;\n    gap: ${(props) => (props.expanded ? '30px' : 0)};\n`\n\nconst PlayerControls = ({ expanded }: { expanded: boolean }): JSX.Element => {\n    const {\n        currentChannel,\n        isPlaying,\n        togglePlayBack,\n        nextChannel,\n        prevChannel,\n    } = useAppContext()\n    if (!currentChannel) {\n        return <Fragment />\n    }\n\n    return (\n        <Container expanded={expanded}>\n            <Button icon={<Previous />} onClick={() => prevChannel()} />\n\n            <IconButton\n                icon={isPlaying ? <PauseFill /> : <PlayFill />}\n                onClick={() => togglePlayBack()}\n                plain={false}\n                size={expanded ? 'large' : undefined}\n            />\n\n            <Button icon={<Next />} onClick={() => nextChannel()} />\n        </Container>\n    )\n}\n\nexport default PlayerControls\n","import PlayerControls from './PlayerControls'\nimport { Favorite, Share } from 'grommet-icons'\nimport { IconButton } from './ChannelInfo.styles'\nimport React, { useEffect, useState } from 'react'\nimport { useAppContext } from './AppContext'\nimport { areEqual, IChannelInfo } from './util'\nimport styled from 'styled-components'\nimport { Box } from 'grommet'\n\nconst Container = styled(Box)`\n    flex-direction: row;\n    align-items: center;\n    gap: 20px;\n`\n\nconst PlayerActions = ({\n    currentChannel,\n    expanded,\n}: {\n    currentChannel: IChannelInfo\n    expanded: boolean\n}): JSX.Element => {\n    const [isFavourite, setIsFavourite] = useState<boolean>(false)\n\n    const { favouriteChannels, toggleFavouriteChannel } = useAppContext()\n\n    useEffect(() => {\n        if (!currentChannel?.id || !favouriteChannels) {\n            return\n        }\n        const favouriteChannel = favouriteChannels.find((channel) =>\n            areEqual(channel.id, currentChannel.id)\n        )\n        if (favouriteChannel && favouriteChannel.id) {\n            setIsFavourite(true)\n            return\n        }\n        setIsFavourite(false)\n    }, [favouriteChannels, currentChannel])\n\n    const handleToggleFavourite = () => {\n        toggleFavouriteChannel(currentChannel)\n    }\n\n    const onHandleShare = async () => {\n        if (!currentChannel || !currentChannel.id) {\n            return\n        }\n\n        if (navigator.share) {\n            const params = new URLSearchParams()\n            params.set('channelId', currentChannel.id)\n\n            try {\n                await navigator.share({\n                    title: currentChannel.title,\n                    text: 'Check out this online radio channel',\n                    url: `${window.location.href.replace(\n                        window.location.search,\n                        ''\n                    )}?${params.toString()}`,\n                })\n            } catch (error) {\n                console.log(`Unable to share ${error}`)\n            }\n        }\n    }\n    return (\n        <Container>\n            {expanded && (\n                <IconButton\n                    icon={<Favorite />}\n                    primary={isFavourite}\n                    onClick={handleToggleFavourite}\n                />\n            )}\n            <PlayerControls expanded={expanded} />\n            {expanded && (\n                <IconButton icon={<Share />} onClick={onHandleShare} />\n            )}\n        </Container>\n    )\n}\n\nexport default PlayerActions\n","import { Button } from 'grommet'\nimport { Down } from 'grommet-icons'\nimport Hls, { ErrorData, ErrorTypes } from 'hls.js'\nimport React, {\n    Fragment,\n    useCallback,\n    useEffect,\n    useRef,\n    useState,\n} from 'react'\nimport styled from 'styled-components'\nimport { useAppContext } from './AppContext'\nimport ChannelInfo from './ChannelInfo'\nimport PlayerActions from './PlayerActions'\nimport { areEqual } from './util'\n\nconst Container = styled.div<{ expanded: boolean }>`\n    position: fixed;\n    left: 0;\n    bottom: 0;\n    width: 100%;\n    background-color: rgba(\n        64,\n        64,\n        64,\n        ${(props) => (props.expanded ? 100 : 80)}%\n    );\n    color: white;\n    text-align: center;\n    display: flex;\n    align-items: center;\n    padding: ${(props) => (props.expanded ? '20px 0' : 0)};\n    flex-direction: ${(props) => (props.expanded ? 'column' : 'row')};\n    justify-content: ${(props) =>\n        props.expanded ? 'space-around' : 'space-between'};\n    box-sizing: border-box;\n    filter: drop-shadow(0 0 0.2rem black);\n    height: ${(props) => (props.expanded ? '100%' : '80px')};\n    transition: height 0.15s ease-in;\n    z-index: 100;\n`\n\nexport interface IPlayerProps {\n    autoPlay?: boolean\n}\n\nconst Player = (props: IPlayerProps): JSX.Element => {\n    const search = window.location.search\n    const params = new URLSearchParams(search)\n    const channelId = params.get('channelId')\n    const [isLoading, setIsLoading] = useState<boolean>(false)\n    const [hasError, setHasError] = useState<boolean>(false)\n    const { currentChannel, isPlaying } = useAppContext()\n    const [isExpanded, setIsExpanded] = useState<boolean>(false)\n    const playerRef = useRef<HTMLMediaElement>(null)\n\n    const init = useCallback(\n        (audioSrc: string): Hls | undefined => {\n            const hls = new Hls({\n                enableWorker: true,\n            })\n\n            if (playerRef.current != null) {\n                hls.attachMedia(playerRef.current)\n            }\n\n            hls.on(Hls.Events.MEDIA_ATTACHED, () => {\n                setHasError(false)\n                setIsLoading(true)\n\n                hls.loadSource(audioSrc)\n\n                hls.on(Hls.Events.MANIFEST_PARSED, () => {\n                    setIsLoading(false)\n                    if (props.autoPlay) {\n                        playerRef?.current\n                            ?.play()\n                            .catch(() =>\n                                console.log(\n                                    'Unable to autoplay prior to user interaction with the dom.'\n                                )\n                            )\n                    }\n                })\n            })\n\n            hls.on(Hls.Events.ERROR, (event, data: ErrorData) => {\n                setHasError(true)\n\n                // if ((data.type === ErrorTypes.NETWORK_ERROR || data.type === ErrorTypes.MEDIA_ERROR) && isPlaying) {\n                //   // togglePlayBack()\n                // }\n\n                if (data.fatal) {\n                    switch (data.type) {\n                        case ErrorTypes.NETWORK_ERROR:\n                            hls.stopLoad()\n                            break\n                        case ErrorTypes.MEDIA_ERROR:\n                            hls.recoverMediaError()\n                            break\n                        default:\n                            break\n                    }\n                }\n            })\n\n            return hls\n        },\n        [props.autoPlay]\n    )\n\n    const getAudioElement = () => {\n        // If Media Source is supported, use HLS.js to play video\n        if (Hls.isSupported()) {\n            return <audio ref={playerRef} />\n        }\n        // Fallback to using a regular video player if HLS is supported by default in the user's browser\n        return (\n            <audio\n                ref={playerRef}\n                src={currentChannel?.audioSrc}\n                autoPlay={props.autoPlay}\n            />\n        )\n    }\n\n    useEffect(() => {\n        let hls: Hls | undefined\n        // Check for Media Source support\n        if (Hls.isSupported() && currentChannel?.audioSrc) {\n            hls = init(currentChannel?.audioSrc)\n\n            document.title = `Radio - ${currentChannel.title}`\n        }\n\n        return () => {\n            if (hls != null) {\n                hls.destroy()\n            }\n        }\n    }, [init, currentChannel])\n\n    useEffect(() => {\n        if (currentChannel && areEqual(currentChannel.id, channelId)) {\n            setIsExpanded(true)\n        }\n    }, [currentChannel, channelId])\n\n    useEffect(() => {\n        if (isPlaying) {\n            setTimeout(() => {\n                if (playerRef.current?.paused && !isLoading) {\n                    playerRef?.current.play()\n                }\n            }, 0)\n\n            return\n        }\n        playerRef.current?.pause()\n    }, [isPlaying, isLoading])\n\n    if (!currentChannel?.audioSrc) {\n        return <Fragment />\n    }\n\n    return (\n        <Container expanded={isExpanded}>\n            {getAudioElement()}\n            {isExpanded && (\n                <Button\n                    icon={<Down size={'large'} />}\n                    onClick={() => setIsExpanded(false)}\n                />\n            )}\n            <ChannelInfo\n                hasError={hasError}\n                isExpanded={isExpanded}\n                isLoading={isLoading}\n                currentChannel={currentChannel}\n                onClick={(expanded: boolean) => {\n                    setIsExpanded(expanded)\n                }}\n            />\n            <PlayerActions\n                currentChannel={currentChannel}\n                expanded={isExpanded}\n            />\n        </Container>\n    )\n}\n\nexport default Player\n","import { Spinner } from 'grommet'\nimport React, { useEffect, useState } from 'react'\nimport styled from 'styled-components'\nimport { useAppContext } from './AppContext'\nimport ChannelsList from './ChannelsList'\nimport Player from './Player'\n\nconst Container = styled.div`\n    min-height: 100%;\n    display: flex;\n    flex-direction: column;\n    justify-content: center;\n    align-items: center;\n    margin-bottom: 80px;\n`\n\nconst Radio = (): JSX.Element => {\n    const { channels, isPlaying } = useAppContext()\n    const [autoPlay, setAutoPlay] = useState<boolean>(false)\n\n    useEffect(() => {\n        if (isPlaying && !autoPlay) {\n            setAutoPlay(true)\n        }\n    }, [autoPlay, isPlaying])\n\n    return (\n        <Container>\n            {channels && channels.length ? (\n                <>\n                    <ChannelsList />\n                    <Player autoPlay={autoPlay} />\n                </>\n            ) : (\n                <Spinner />\n            )}\n        </Container>\n    )\n}\n\nexport default Radio\n","import { Grommet } from 'grommet'\nimport React, { useEffect } from 'react'\nimport { AppContextProvider } from './AppContext'\nimport Header from './Header'\nimport theme from './index.style'\nimport Radio from './Radio'\nimport { resizeToMinimum } from './util'\n\nconst App = (): JSX.Element => {\n    useEffect(() => {\n        window.addEventListener('resize', resizeToMinimum)\n        window.addEventListener('load', resizeToMinimum)\n\n        return () => {\n            window.removeEventListener('resize', resizeToMinimum)\n            window.removeEventListener('load', resizeToMinimum)\n        }\n    }, [])\n    return (\n        <Grommet full theme={theme}>\n            <AppContextProvider>\n                <Header />\n                <Radio />\n            </AppContextProvider>\n        </Grommet>\n    )\n}\n\nexport default App\n","import React from 'react'\nimport { render } from 'react-dom'\nimport App from './App'\n\nrender(<App />, document.getElementById('root'))\n"],"sourceRoot":""}