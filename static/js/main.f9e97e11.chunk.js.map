{"version":3,"sources":["util.ts","AppContext.tsx","ErrorBoundary.tsx","Header.tsx","index.style.ts","ChannelsList.tsx","ChannelInfo.styles.tsx","ChannelInfo.tsx","PlayerControls.tsx","Player.tsx","Radio.tsx","App.tsx","index.tsx"],"names":["fetchChannels","a","fetch","headers","process","json","response","areEqual","id1","id2","toString","resizeToMinimum","minimum","current","window","outerWidth","outerHeight","restricted","index","length","resizeTo","AppContext","createContext","channels","favouriteChannels","undefined","currentChannel","isPlaying","updateCurrentChannel","channelId","togglePlayBack","nextChannel","prevChannel","toggleFavouriteChannel","info","AppContextProvider","children","search","location","URLSearchParams","get","useState","setCurrentChannel","setIsPlaying","setChannels","setFavouriteChannels","STORAGE_KEY_FAVOURITE_CHANNELS","STORAGE_KEY_CURRENT_CHANNEL","useEffect","init","localStorage","getItem","JSON","parse","useCallback","autoPlay","newChannel","find","channel","id","getCurrentChannelIndex","findIndex","prevSelectedChannel","error","console","log","setItem","stringify","currentChannelIndex","Provider","value","currentFavouriteChannels","filter","useAppContext","useContext","ErrorBoundary","state","hasError","this","props","Component","OuterWrapper","styled","div","InnerWrapper","IconImage","img","formatSuggestions","suggestedChannels","suggestedChannel","title","toLowerCase","indexOf","map","list","label","Box","direction","align","gap","border","pad","Image","width","src","imageSrc","style","borderRadius","Text","size","Header","selectedChannel","setSelectedChannel","suggestionOpen","setSuggestionOpen","suggestions","setSuggestions","selectedChannelTitle","setSelectedChannelTitle","onInputChange","event","newValue","target","trim","onSuggestionSelect","suggestion","onSuggestionsOpen","onSuggestionsClose","alt","elevation","borderBottomLeftRadius","borderBottomRightRadius","TextInput","icon","Search","reverse","placeholder","onChange","theme","deepMerge","dark","global","drop","background","shadowSize","extend","medium","light","font","family","input","weight","ItemWrapper","attrs","backgroundImage","image","ChannelDetails","onClick","ChannelsList","item","Container","expanded","MediaArtContainer","MediaArt","IconButton","Button","ChannelInfo","isExpanded","isLoading","setExpanded","isFavourite","setIsFavourite","favouriteChannel","onHandleShare","navigator","share","params","set","text","url","href","replace","Favorite","primary","Share","textAlign","Spinner","StatusWarning","Wrapper","PlayerControls","Previous","PauseFill","PlayFill","plain","Next","Player","setIsLoading","setHasError","setIsExpanded","playerRef","useRef","audioSrc","hls","Hls","enableWorker","attachMedia","on","Events","MEDIA_ATTACHED","loadSource","MANIFEST_PARSED","play","catch","ERROR","data","fatal","type","ErrorTypes","NETWORK_ERROR","stopLoad","MEDIA_ERROR","recoverMediaError","isSupported","document","destroy","setTimeout","paused","pause","ref","Down","Radio","setAutoPlay","App","addEventListener","removeEventListener","Grommet","full","render","getElementById"],"mappings":"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","file":"static/js/main.f9e97e11.chunk.js","sourcesContent":["\nexport interface IChannelInfo {\n  id: string;\n  title: string;\n  imageSrc: string;\n  audioSrc: string;\n}\n\nconst fetchChannels = async (): Promise<IChannelInfo[]> => {\n  const response = await (await fetch(\n    'https://player-b7f2.restdb.io/rest/air-channels'\n    , {\n      headers: {\n        'x-apikey': process.env.REACT_APP_RESTDB_API_KEY!\n      }\n    })).json();\n  return response as IChannelInfo[];\n};\n\nconst areEqual = (id1: string | number | null, id2: string | number | null): boolean => {\n  if (!id1 || !id2) {\n    return false;\n  }\n  return id1.toString() === id2.toString();\n}\n\nconst resizeToMinimum = () => {\n  const minimum: [number, number] = [500, 640];\n  const current: [number, number] = [window.outerWidth, window.outerHeight];\n  const restricted: [number, number] = current;\n\n  for (let index = 0; index < restricted.length; index++) {\n    restricted[index] = minimum[index] > current[index] ? minimum[index] : current[index];\n  }\n\n  window.resizeTo(restricted[0], restricted[1]);\n}\n\n\nexport {\n  fetchChannels,\n  areEqual,\n  resizeToMinimum\n};\n","import React, {\n  createContext,\n  useState,\n  useContext,\n  useEffect,\n  useCallback\n} from 'react';\nimport { areEqual, fetchChannels, IChannelInfo } from './util';\n\ntype AppContextParams = {\n  channels: IChannelInfo[];\n  favouriteChannels: IChannelInfo[] | undefined;\n  currentChannel: IChannelInfo | null;\n  isPlaying: boolean;\n  updateCurrentChannel: (channelId: string) => void;\n  togglePlayBack: () => void;\n  nextChannel: () => void;\n  prevChannel: () => void;\n  toggleFavouriteChannel: (info: IChannelInfo) => void;\n};\n\nexport const AppContext = createContext<AppContextParams>({\n  channels: [],\n  favouriteChannels: undefined,\n  currentChannel: null,\n  isPlaying: false,\n  updateCurrentChannel: (channelId: string) => { },\n  togglePlayBack: () => { },\n  nextChannel: () => { },\n  prevChannel: () => { },\n  toggleFavouriteChannel: (info: IChannelInfo) => { }\n});\n\nexport const AppContextProvider = ({\n  children\n}: {\n  children: JSX.Element[] | JSX.Element;\n}): JSX.Element => {\n  const search = window.location.search;\n  const params = new URLSearchParams(search);\n  const channelId = params.get('channelId');\n  const [currentChannel, setCurrentChannel] = useState<IChannelInfo | null>(null);\n  const [isPlaying, setIsPlaying] = useState<boolean>(false);\n  const [channels, setChannels] = useState<IChannelInfo[]>([]);\n  const [favouriteChannels, setFavouriteChannels] = useState<IChannelInfo[]>()\n\n  const STORAGE_KEY_FAVOURITE_CHANNELS = 'favouriteChannels';\n  const STORAGE_KEY_CURRENT_CHANNEL = 'currentChannel';\n\n  useEffect(() => {\n    void init();\n  }, []);\n\n  const init = async () => {\n    setChannels(await fetchChannels());\n    const favouriteChannels = localStorage.getItem(STORAGE_KEY_FAVOURITE_CHANNELS);\n\n    if (favouriteChannels) {\n      setFavouriteChannels(JSON.parse(favouriteChannels))\n    }\n  };\n\n  const updateCurrentChannel = useCallback((\n    channelId: string,\n    autoPlay: boolean = true\n  ) => {\n    const newChannel = channels.find(channel => areEqual(channel.id, channelId));\n    if (newChannel) {\n      setCurrentChannel(newChannel);\n    }\n\n    if (autoPlay && !isPlaying) {\n      setIsPlaying(true);\n    }\n  }, [channels, isPlaying]);\n\n  const getCurrentChannelIndex = useCallback(\n    () => channels.findIndex(channel => currentChannel && areEqual(channel.id, currentChannel.id)),\n    [channels, currentChannel]\n  );\n\n  useEffect(() => {\n    if (!channels || !channels.length) {\n      return;\n    }\n\n    if (channelId) {\n      updateCurrentChannel(channelId, false);\n      return;\n    }\n\n    const prevSelectedChannel = localStorage.getItem(STORAGE_KEY_CURRENT_CHANNEL);\n    if (prevSelectedChannel) {\n      try {\n        setCurrentChannel(JSON.parse(prevSelectedChannel));\n      } catch (error) {\n        console.log({ error });\n      }\n    }\n  }, [channels, channelId, updateCurrentChannel]);\n\n  useEffect(() => {\n    if (!currentChannel) {\n      return;\n    }\n    localStorage.setItem(STORAGE_KEY_CURRENT_CHANNEL, JSON.stringify(currentChannel));\n  }, [currentChannel]);\n\n  useEffect(() => {\n    if (favouriteChannels) {\n      localStorage.setItem(STORAGE_KEY_FAVOURITE_CHANNELS, JSON.stringify(favouriteChannels));\n    }\n  }, [favouriteChannels])\n\n\n  const nextChannel = useCallback(() => {\n    const currentChannelIndex = getCurrentChannelIndex();\n\n    if (currentChannelIndex < channels.length - 1) {\n      setCurrentChannel(channels[currentChannelIndex + 1]);\n      return;\n    }\n\n    setCurrentChannel(channels[0]);\n  }, [channels, getCurrentChannelIndex]);\n\n  const prevChannel = useCallback(() => {\n    const currentChannelIndex = getCurrentChannelIndex();\n\n    if (currentChannelIndex >= 1) {\n      setCurrentChannel(channels[currentChannelIndex - 1]);\n      return;\n    }\n\n    setCurrentChannel(channels[channels.length - 1]);\n  }, [channels, getCurrentChannelIndex]);\n\n\n  const togglePlayBack = () => {\n    setIsPlaying(isPlaying => !isPlaying);\n  };\n\n  const toggleFavouriteChannel = (info: IChannelInfo) => {\n    if (favouriteChannels) {\n      const favouriteChannel = favouriteChannels.find(channel => areEqual(channel.id, info.id));\n\n      if (favouriteChannel) { // remove from favourite and return \n        setFavouriteChannels(currentFavouriteChannels => currentFavouriteChannels?.filter(channel => !areEqual(channel.id, info.id)));\n        return;\n      }\n    }\n\n\n    setFavouriteChannels(currentFavouriteChannels => {\n      if (!currentFavouriteChannels) {\n        currentFavouriteChannels = []\n      };\n\n      return [...currentFavouriteChannels, info]\n    });\n  }\n\n  return (\n    <AppContext.Provider\n      value={{\n        channels,\n        favouriteChannels,\n        currentChannel,\n        isPlaying,\n        updateCurrentChannel,\n        togglePlayBack,\n        nextChannel,\n        prevChannel,\n        toggleFavouriteChannel\n      }}\n    >\n      {children}\n    </AppContext.Provider>\n  );\n};\n\nexport const useAppContext = (): AppContextParams => useContext(AppContext);\n","import React, { Component } from 'react';\n\ninterface IErrorState {\n  hasError: boolean;\n}\nclass ErrorBoundary extends Component<{}, IErrorState> {\n  state = { hasError: false };\n\n  static getDerivedStateFromError(error: unknown) {\n    if (error) {\n      console.log(error);\n      return { hasError: true };\n    }\n  }\n\n  componentDidCatch(error: unknown, info: unknown) {\n    console.log(error, info);\n  }\n\n  render() {\n    if (this.state.hasError) {\n      // You can render any custom fallback UI\n      return <h1>Something went wrong.</h1>;\n    }\n\n    return this.props.children;\n  }\n}\n\nexport default ErrorBoundary;\n","import { Box, Image, Text, TextInput } from 'grommet';\nimport { Search } from 'grommet-icons';\nimport React, { useCallback, useEffect, useState } from 'react';\nimport styled from 'styled-components';\nimport { useAppContext } from './AppContext';\nimport { IChannelInfo } from './util';\n\nconst OuterWrapper = styled.div`\n  position: sticky;\n  top: 0;\n  z-index: 3;\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  background-color: #fff;\n  background-color: var(--bg-primary-color);\n  filter: drop-shadow(0 0 0.20rem black);\n`;\nconst InnerWrapper = styled.div`\n  display: flex;\n  flex-direction: row;\n  justify-content: center;\n  justify-content: space-between;\n  padding: 0 20px;\n  height: 72px;\n  border-bottom: 1px solid grey;\n  background-color: rgba(64, 64, 64, .8);\n  align-items: center;\n`;\n\nconst IconImage = styled.img`\n  border-radius: 50%;\n  width: 48px;\n  ::before {\n     content: '';\n     width: 48px;\n     height: 48px;\n     background-color: #ccc;\n     border-radius: 50%;\n     position: absolute;\n     top: 50%;\n     left: 24px;\n     transform: translateY(-50%);\n }\n`\n\ninterface ISuggestion {\n  label: JSX.Element, value: string, channel: IChannelInfo\n}\n\nconst formatSuggestions = (suggestedChannels: IChannelInfo[], value: string = ''): ISuggestion[] =>\n  suggestedChannels\n    .filter(\n      suggestedChannel =>\n        suggestedChannel.title.toLowerCase().indexOf(value.toLowerCase()) >= 0\n    )\n    .map((suggestedChannel, index, list) => ({\n      label: (\n        <Box\n          direction=\"row\"\n          align=\"center\"\n          gap=\"small\"\n          border={index < list.length - 1 ? 'bottom' : undefined}\n          pad=\"small\"\n        >\n          <Image\n            width=\"80px\"\n            src={suggestedChannel.imageSrc}\n            style={{ borderRadius: '8px' }}\n          />\n          <Text size={'small'}>\n            {suggestedChannel?.title}\n          </Text>\n        </Box>\n      ),\n      value: suggestedChannel.title,\n      channel: suggestedChannel\n    }));\n\nconst Header = (): JSX.Element => {\n  const { channels, updateCurrentChannel } = useAppContext();\n  const [selectedChannel, setSelectedChannel] = useState<IChannelInfo>();\n  const [suggestionOpen, setSuggestionOpen] = useState(false);\n  const [suggestions, setSuggestions] = useState<ISuggestion[]>([]);\n  const [selectedChannelTitle, setSelectedChannelTitle] = useState<string>('')\n\n  useEffect(() => {\n    if (selectedChannel && selectedChannel.id) {\n      updateCurrentChannel(selectedChannel.id)\n    }\n\n  }, [selectedChannel, updateCurrentChannel])\n\n  const onInputChange = useCallback(\n    event => {\n      const { value: newValue } = event.target;\n      setSelectedChannelTitle(newValue);\n      setSelectedChannel(newValue)\n\n      if (!newValue.trim()) {\n        setSuggestions([]);\n      } else {\n        setSuggestions(formatSuggestions(channels, newValue));\n      }\n    },\n    [channels]\n  );\n\n  const onSuggestionSelect = useCallback(\n    event => {\n      setSelectedChannel(event.suggestion.channel);\n      setSelectedChannelTitle(event.suggestion.value);\n    },\n    []\n  );\n\n  const onSuggestionsOpen = useCallback(() => {\n    setSuggestions(formatSuggestions(channels, selectedChannel?.title));\n    setSuggestionOpen(true);\n  }, [channels, selectedChannel]);\n\n  const onSuggestionsClose = useCallback(() => {\n    setSuggestions([]);\n    setSuggestionOpen(false);\n    setSelectedChannel(undefined);\n    setSelectedChannelTitle('')\n  }, []);\n\n  return (\n    <OuterWrapper>\n      <InnerWrapper>\n        <IconImage src={process.env.PUBLIC_URL + '/assets/icons/icon-x192.png'} alt='Logo' />\n        <Box\n          width=\"medium\"\n          gap=\"medium\"\n          direction=\"row\"\n          align=\"center\"\n          elevation={suggestionOpen ? 'medium' : undefined}\n          style={\n            suggestionOpen\n              ? {\n                borderBottomLeftRadius: '0px',\n                borderBottomRightRadius: '0px',\n              }\n              : undefined\n          } pad={{ 'left': 'large' }}>\n          <TextInput\n            icon={<Search />}\n            reverse\n            placeholder=\"search\"\n            suggestions={suggestions}\n            value={selectedChannelTitle}\n            onChange={onInputChange}\n            onSuggestionsOpen={onSuggestionsOpen}\n            onSuggestionsClose={onSuggestionsClose}\n            onSuggestionSelect={onSuggestionSelect}\n          />\n        </Box>\n\n      </InnerWrapper>\n    </OuterWrapper>\n  );\n};\n\nexport default Header;\n","import { dark, ThemeType } from 'grommet/themes';\nimport { deepMerge } from 'grommet/utils';\n\nconst theme: ThemeType = deepMerge(dark, {\n    global: {\n        drop: {\n            background: '#444444',\n            shadowSize: 'medium',\n            extend: `\n          border-bottom-left-radius: 12px;\n          border-bottom-right-radius: 12px;\n          overflow: hidden;\n        `\n        },\n        elevation: {\n            dark: {\n                medium: '0 10px 20px rgba(0,0,0,0.19), 0 6px 6px rgba(0,0,0,0.23)'\n            },\n            light: {\n                medium: '0 10px 20px rgba(0,0,0,0.19), 0 6px 6px rgba(0,0,0,0.23)'\n            }\n        },\n        font: {\n            size: '14px',\n            family: 'Sora'\n        },\n        input: {\n            weight: 400\n        }\n    }\n});\n\nexport default theme;","import React, { Fragment } from 'react';\nimport styled from 'styled-components';\nimport { useAppContext } from './AppContext';\nimport { IChannelInfo } from './util';\nconst OuterWrapper = styled.div``;\n\nconst Header = styled.div`\n  margin: 12px 20px;\n`;\n\nconst InnerWrapper = styled.div`\n  display: flex;\n  flex-flow: row wrap;\n  justify-content: center;\n  gap: 18px;\n  padding: 10px;\n  max-width: 800px;\n`;\nconst ItemWrapper = styled.div.attrs((props: { image: string }) => ({\n  style: {\n    backgroundImage: `url(${props.image})`\n  }\n})) <{ image: string }>`\n  border-radius: 8px;\n  overflow: hidden;\n  position: relative;\n  display: flex;\n  cursor: pointer;\n  background-repeat: no-repeat;\n  background-size: contain;\n  background-position: center;\n  width: 160px;\n  height: 160px;\n  border: 0.2px solid white;\n  background-color: white;\n  filter: drop-shadow(0 0 0.15rem white);\n\n  :hover {\n    opacity: 0.8;\n    cursor: pointer;\n  }\n`;\n\nconst ChannelDetails = (props: IChannelInfo) => {\n  const { updateCurrentChannel } = useAppContext();\n  return (\n    <ItemWrapper\n      image={props.imageSrc}\n      onClick={() => {\n        updateCurrentChannel(props.id);\n      }}\n    >\n      {/* <span>{props.title}</span> */}\n    </ItemWrapper>\n  );\n};\n\nconst ChannelsList = (): JSX.Element => {\n  const { channels, favouriteChannels } = useAppContext();\n\n  return (\n    <OuterWrapper>\n      {favouriteChannels && favouriteChannels.length &&\n        <Fragment>\n          <Header>Your favourite Stations</Header>\n          <InnerWrapper>\n            {favouriteChannels.map(item => (\n              <ChannelDetails key={item.id} {...item} />\n            ))}\n          </InnerWrapper>\n        </Fragment>}\n\n      <Header>On-Air Stations</Header>\n      <InnerWrapper>\n        {channels.map(item => (\n          <ChannelDetails key={item.id} {...item} />\n        ))}\n      </InnerWrapper>\n    </OuterWrapper>\n  );\n};\n\nexport default ChannelsList;\n","import styled from 'styled-components'\nimport { Box, Button } from 'grommet'\n\nconst Container = styled.div<{ expanded: boolean }>`\n    display: flex;\n    justify-content: ${(props) => (props.expanded ? 'center' : 'left')};\n    align-items: center;\n    font-size: 16px;\n    gap: ${(props) => (props.expanded ? '50px' : '10px')};\n    padding: ${(props) => (props.expanded ? '10px' : undefined)};\n    width: ${(props) => (props.expanded ? '100%' : undefined)};\n    flex-direction: ${(props) => (props.expanded ? 'column' : 'row')};\n    cursor: pointer;\n`\n\nconst MediaArtContainer = styled(Box)<{ expanded: boolean }>`\n    flex-direction: row;\n    justify-content: center;\n    align-items: center;\n    gap: 20px;\n    width ${(props) => (props.expanded ? '100%' : undefined)};\n    padding: 0 15px\n`\n\nconst MediaArt = styled.img<{ expanded: boolean }>`\n    width: ${(props) => (props.expanded ? '30vh' : '60px')};\n    max-height: 30vh;\n    max-width: ${(props) => (props.expanded ? '50vh' : '60px')};\n    transition: max-width 0.15s ease-in-out;\n    border-radius: 6px;\n`\n\nconst IconButton = styled(Button)`\n    padding: 18px;\n`\n\nexport { Container, MediaArtContainer, MediaArt, IconButton }\n","import { Spinner } from 'grommet'\nimport { Favorite, Share, StatusWarning } from 'grommet-icons'\nimport { Text } from 'grommet/components/Text'\nimport React, { useEffect, useState } from 'react'\nimport { useAppContext } from './AppContext'\nimport { areEqual, IChannelInfo } from './util'\nimport {\n    Container,\n    IconButton,\n    MediaArt,\n    MediaArtContainer,\n} from './ChannelInfo.styles'\n\ninterface IChannelInfoProps {\n    isLoading: boolean\n    hasError: boolean\n    isExpanded: boolean\n    currentChannel: IChannelInfo\n    onClick: (expanded: boolean) => void\n}\n\nconst ChannelInfo = ({\n    isExpanded,\n    isLoading,\n    hasError,\n    currentChannel,\n    onClick,\n}: IChannelInfoProps) => {\n    const [expanded, setExpanded] = useState<boolean>(false)\n    const [isFavourite, setIsFavourite] = useState<boolean>(false)\n\n    const { favouriteChannels, toggleFavouriteChannel } = useAppContext()\n\n    useEffect(() => {\n        setExpanded(isExpanded)\n    }, [isExpanded])\n\n    useEffect(() => {\n        if (!currentChannel?.id || !favouriteChannels) {\n            return\n        }\n        const favouriteChannel = favouriteChannels.find((channel) =>\n            areEqual(channel.id, currentChannel.id)\n        )\n        if (favouriteChannel && favouriteChannel.id) {\n            setIsFavourite(true)\n            return\n        }\n        setIsFavourite(false)\n    }, [favouriteChannels, currentChannel])\n\n    const handleOnClick = () => {\n        setExpanded(true)\n        onClick(true)\n    }\n\n    const handleToggleFavourite = () => {\n        toggleFavouriteChannel(currentChannel)\n    }\n\n    const onHandleShare = async () => {\n        if (!currentChannel || !currentChannel.id) {\n            return\n        }\n\n        if (navigator.share) {\n            const params = new URLSearchParams()\n            params.set('channelId', currentChannel.id)\n\n            try {\n                await navigator.share({\n                    title: currentChannel.title,\n                    text: 'Check out this online radio channel',\n                    url: `${window.location.href.replace(\n                        window.location.search,\n                        ''\n                    )}?${params.toString()}`,\n                })\n            } catch (error) {\n                console.log(`Unable to share ${error}`)\n            }\n        }\n    }\n\n    return (\n        <Container expanded={expanded} onClick={handleOnClick}>\n            <MediaArtContainer expanded={expanded}>\n                {expanded && (\n                    <IconButton\n                        icon={<Favorite />}\n                        primary={isFavourite}\n                        onClick={handleToggleFavourite}\n                    />\n                )}\n                {currentChannel?.imageSrc && (\n                    <MediaArt\n                        expanded={expanded}\n                        src={currentChannel.imageSrc}\n                        alt=\"Media art\"\n                    />\n                )}\n                {expanded && (\n                    <IconButton icon={<Share />} onClick={onHandleShare} />\n                )}\n            </MediaArtContainer>\n\n            <Text size={expanded ? 'xlarge' : 'small'} textAlign={'start'}>\n                {currentChannel?.title}\n            </Text>\n\n            {isLoading && !hasError && <Spinner />}\n            {hasError && <StatusWarning />}\n        </Container>\n    )\n}\n\nexport default ChannelInfo\n","import { Button } from 'grommet';\nimport React, { Fragment } from 'react';\nimport styled from 'styled-components';\nimport { useAppContext } from './AppContext';\n\nimport { PlayFill, PauseFill, Next, Previous } from 'grommet-icons'\n\nconst Wrapper = styled.div`\n  display: flex;\n  align-items: center;\n`;\n\nconst PlayerControls = (): JSX.Element => {\n  const {\n    currentChannel,\n    isPlaying,\n    togglePlayBack,\n    nextChannel,\n    prevChannel\n  } = useAppContext();\n  if (!currentChannel) {\n    return <Fragment />;\n  }\n\n  return (\n    <Wrapper>\n      <Button\n        icon={<Previous />}\n        onClick={() => prevChannel()}\n      />\n\n      <Button\n        icon={isPlaying ? <PauseFill /> : <PlayFill />}\n        onClick={() => togglePlayBack()}\n        plain={false}\n        size={'large'}\n      />\n\n      <Button\n        icon={<Next />}\n        onClick={() => nextChannel()}\n      />\n    </Wrapper>\n  );\n};\n\nexport default PlayerControls;\n","import { Button } from 'grommet';\nimport { Down } from 'grommet-icons';\nimport Hls, { ErrorData, ErrorTypes } from 'hls.js';\nimport React, { Fragment, useCallback, useEffect, useRef, useState } from 'react';\nimport styled from 'styled-components';\nimport { useAppContext } from './AppContext';\nimport ChannelInfo from './ChannelInfo';\nimport PlayerControls from './PlayerControls';\nimport { areEqual } from './util';\n\n\nconst Container = styled.div<{ expanded: boolean }>`\n    position: fixed;\n    left: 0;\n    bottom: 0;\n    width: 100%;\n    background-color: rgba(\n        64,\n        64,\n        64,\n        ${(props) => (props.expanded ? 100 : 80)}%\n    );\n    color: white;\n    text-align: center;\n    display: flex;\n    align-items: center;\n    padding: ${(props) => (props.expanded ? '20px 0' : 0)};\n    flex-direction: ${(props) => (props.expanded ? 'column' : 'row')};\n    justify-content: ${(props) =>\n        props.expanded ? 'space-around' : 'space-between'};\n    box-sizing: border-box;\n    filter: drop-shadow(0 0 0.2rem black);\n    height: ${(props) => (props.expanded ? '100%' : '80px')};\n    transition: height 0.15s ease-in;\n    z-index: 100;\n`\n\nexport interface IPlayerProps {\n    autoPlay?: boolean\n}\n\nconst Player = (props: IPlayerProps): JSX.Element => {\n    const search = window.location.search\n    const params = new URLSearchParams(search)\n    const channelId = params.get('channelId')\n    const [isLoading, setIsLoading] = useState<boolean>(false)\n    const [hasError, setHasError] = useState<boolean>(false)\n    const { currentChannel, isPlaying } = useAppContext()\n    const [isExpanded, setIsExpanded] = useState<boolean>(false)\n    const playerRef = useRef<HTMLMediaElement>(null)\n\n    const init = useCallback(\n        (audioSrc: string): Hls | undefined => {\n            const hls = new Hls({\n                enableWorker: true,\n            })\n\n            if (playerRef.current != null) {\n                hls.attachMedia(playerRef.current)\n            }\n\n            hls.on(Hls.Events.MEDIA_ATTACHED, () => {\n                setHasError(false)\n                setIsLoading(true)\n\n                hls.loadSource(audioSrc)\n\n                hls.on(Hls.Events.MANIFEST_PARSED, () => {\n                    setIsLoading(false)\n                    if (props.autoPlay) {\n                        playerRef?.current\n                            ?.play()\n                            .catch(() =>\n                                console.log(\n                                    'Unable to autoplay prior to user interaction with the dom.'\n                                )\n                            )\n                    }\n                })\n            })\n\n            hls.on(Hls.Events.ERROR, (event, data: ErrorData) => {\n                setHasError(true)\n\n                // if ((data.type === ErrorTypes.NETWORK_ERROR || data.type === ErrorTypes.MEDIA_ERROR) && isPlaying) {\n                //   // togglePlayBack()\n                // }\n\n                if (data.fatal) {\n                    switch (data.type) {\n                        case ErrorTypes.NETWORK_ERROR:\n                            hls.stopLoad()\n                            break\n                        case ErrorTypes.MEDIA_ERROR:\n                            hls.recoverMediaError()\n                            break\n                        default:\n                            break\n                    }\n                }\n            })\n\n            return hls\n        },\n        [props.autoPlay]\n    )\n\n    const getAudioElement = () => {\n        // If Media Source is supported, use HLS.js to play video\n        if (Hls.isSupported()) {\n            return <audio ref={playerRef} />\n        }\n        // Fallback to using a regular video player if HLS is supported by default in the user's browser\n        return (\n            <audio\n                ref={playerRef}\n                src={currentChannel?.audioSrc}\n                autoPlay={props.autoPlay}\n            />\n        )\n    }\n\n    useEffect(() => {\n        let hls: Hls | undefined\n        // Check for Media Source support\n        if (Hls.isSupported() && currentChannel?.audioSrc) {\n            hls = init(currentChannel?.audioSrc)\n\n            document.title = `Radio - ${currentChannel.title}`\n        }\n\n        return () => {\n            if (hls != null) {\n                hls.destroy()\n            }\n        }\n    }, [init, currentChannel])\n\n    useEffect(() => {\n        if (currentChannel && areEqual(currentChannel.id, channelId)) {\n            setIsExpanded(true)\n        }\n    }, [currentChannel, channelId])\n\n    useEffect(() => {\n        if (isPlaying) {\n            setTimeout(() => {\n                if (playerRef.current?.paused && !isLoading) {\n                    playerRef?.current.play()\n                }\n            }, 0)\n\n            return\n        }\n        playerRef.current?.pause()\n    }, [isPlaying, isLoading])\n\n    if (!currentChannel?.audioSrc) {\n        return <Fragment />\n    }\n\n    return (\n        <Container expanded={isExpanded}>\n            {getAudioElement()}\n            {isExpanded && (\n                <Button\n                    icon={<Down size={'large'} />}\n                    onClick={() => setIsExpanded(false)}\n                />\n            )}\n            <ChannelInfo\n                hasError={hasError}\n                isExpanded={isExpanded}\n                isLoading={isLoading}\n                currentChannel={currentChannel}\n                onClick={(expanded: boolean) => {\n                    setIsExpanded(expanded)\n                }}\n            />\n            <PlayerControls />\n        </Container>\n    )\n}\n\n\nexport default Player;\n","import { Spinner } from 'grommet';\nimport React, { useEffect, useState } from 'react';\nimport styled from 'styled-components';\nimport { useAppContext } from './AppContext';\nimport ChannelsList from './ChannelsList';\nimport Player from './Player';\n\nconst Container = styled.div`\n  min-height: 100%;\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  align-items: center;\n  margin-bottom: 80px;\n`;\n\nconst Radio = () => {\n  const { channels, isPlaying } = useAppContext();\n  const [autoPlay, setAutoPlay] = useState<boolean>(false);\n\n  useEffect(() => {\n    if (isPlaying && !autoPlay) {\n      setAutoPlay(true);\n    }\n  }, [autoPlay, isPlaying]);\n\n  return (\n    <Container>\n      {channels && channels.length ? <>\n        <ChannelsList />\n        <Player autoPlay={autoPlay} />\n      </> : <Spinner />}\n    </Container>\n  );\n};\n\nexport default Radio;\n","import { Grommet } from 'grommet';\nimport React, { useEffect } from 'react';\nimport { AppContextProvider } from './AppContext';\nimport ErrorBoundary from './ErrorBoundary';\nimport Header from './Header';\nimport theme from './index.style';\nimport Radio from './Radio';\nimport { resizeToMinimum } from './util';\n\n\nconst App = () => {\n    useEffect(() => {\n        window.addEventListener('resize', resizeToMinimum);\n        window.addEventListener('load', resizeToMinimum)\n\n        return () => {\n            window.removeEventListener('resize', resizeToMinimum);\n            window.removeEventListener('load', resizeToMinimum)\n        }\n\n    }, [])\n    return (\n        <ErrorBoundary>\n            <Grommet full theme={theme}>\n                <AppContextProvider>\n                    <Header />\n                    <Radio />\n                </AppContextProvider>\n            </Grommet>\n        </ErrorBoundary>\n    )\n}\n\nexport default App;","import React from 'react';\nimport { render } from 'react-dom';\nimport App from './App';\n\nrender(\n  <App /> ,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}